---
layout: default
style: luadoc
title: Class Reference
---

<p class="warning">
This documention is far from complete may be inaccurate and subject to change.
</p>


<div id="luaref">


<h2 id="h_intro">Overview</h2>
<p>
The top-level entry point are <a class="" href="#ARDOUR:Session">ARDOUR:Session</a> and <a class="" href="#ArdourUI:Editor">ArdourUI:Editor</a>.
Most other Classes are used indirectly starting with a Session function. e.g. Session:get_routes().
</p>
<p>
A few classes are dedicated to certain script types, e.g. Lua DSP processors have exclusive access to
<a class="" href="#ARDOUR:DSP">ARDOUR.DSP</a> and <a class="" href="#ARDOUR:ChanMapping">ARDOUR:ChanMapping</a>. Action Hooks Scripts to
<a class="" href="#LuaSignal:Set">LuaSignal:Set</a> etc.
</p>
<p>
Detailed documentation (parameter names, method description) is not yet available. Please stay tuned.
</p>
<h3>Short introduction to Ardour classes</h3>
<p>
Ardour's structure is object oriented. The main object is the Session. A Session contains Audio Tracks, Midi Tracks and Busses.
Audio and Midi tracks are derived from a more general "Track" Object,  which in turn is derived from a "Route" (aka Bus).
(We say "An Audio Track <em>is-a</em> Track <em>is-a</em> Route").
Tracks contain specifics. For Example a track <em>has-a</em> diskstream (for file i/o).
</p>
<p>
Operations are performed on objects. One gets a reference to an object and then calls a method.
e.g <code>obj = Session:route_by_name("Audio")   obj:set_name("Guitar")</code>.
</p>
<p>
Object lifetimes are managed by the Session. Most Objects cannot be directly created, but one asks the Session to create or destroy them. This is mainly due to realtime constrains:
you cannot simply remove a track that is currently processing audio. There are various <em>factory</em> methods for object creation or removal.
</p>
<h3>Pass by Reference</h3>
<p>
Since lua functions are closures, C++ methods that pass arguments by reference cannot be used as-is.
All parameters passed to a C++ method which uses references are returned as Lua Table.
If the C++ method also returns a value it is prefixed. Two parameters are returned: the value and a Lua Table holding the parameters.
</p>

<div class="code">
	<div style="float:left;">C++

<pre><code class="cxx">void set_ref (int&amp; var, long&amp; val)
{
	printf ("%d %ld\n", var, val);
	var = 5;
	val = 7;
}
</code></pre>

	</div>
	<div style="float:right;">Lua

<pre><code class="lua">local var = 0;
ref = set_ref (var, 2);
-- output from C++ printf()
</code><samp class="lua">0 2</samp><code>
-- var is still 0 here
print (ref[1], ref[2])
</code><samp class="lua">5 7</samp></pre>

	</div>
</div>
<div class="clear"></div>
<div class="code">
	<div style="float:left;">

<pre><code class="cxx">int set_ref2 (int &amp;var, std::string unused)
{
	var = 5;
	return 3;
}
</code></pre>

	</div>
	<div style="float:right;">
<pre><code class="lua">rv, ref = set_ref2 (0, "hello");
print (rv, ref[1], ref[2])
</code><samp class="lua">3 5 hello</samp></pre>
	</div>
</div>
<div class="clear"></div>

<h3>Pointer Classes</h3>
<p>
Libardour makes extensive use of reference counted <code>boost::shared_ptr</code> to manage lifetimes.
The Lua bindings provide a complete abstration of this. There are no pointers in lua.
For example a <a class="" href="#ARDOUR:Route">ARDOUR:Route</a> is a pointer in C++, but lua functions operate on it like it was a class instance.
</p>
<p>
<code>shared_ptr</code> are reference counted. Once assigned to a lua variable, the C++ object will be kept and remains valid.
It is good practice to assign references to lua <code>local</code> variables or reset the variable to <code>nil</code> to drop the ref.
</p>
<p>
All pointer classes have a <code>isnil ()</code> method. This is for two cases:
Construction may fail. e.g. <code><a class="" href="#ARDOUR:LuaAPI">ARDOUR.LuaAPI</a>.newplugin()</code>
may not be able to find the given plugin and hence cannot create an object.
</p>
<p>
The second case if for <code>boost::weak_ptr</code>. As opposed to <code>boost::shared_ptr</code> weak-pointers are not reference counted.
The object may vanish at any time.
If lua code calls a method on a nil object, the interpreter will raise an exception and the script will not continue.
This is not unlike <code>a = nil a:test()</code> which results in en error "<em>attempt to index a nil value</em>".
</p>
<p>
From the lua side of things there is no distinction between weak and shared pointers. They behave identically.
Below they're inidicated in orange and have an arrow to indicate the pointer type.
Pointer Classes cannot be created in lua scripts. It always requires a call to C++ to create the Object and obtain a reference to it.
</p>


<h2 id="h_classes">Class Documentation</h2>
<h3 id="ARDOUR:AudioBackend" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:AudioBackend</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::AudioBackend &gt;, boost::weak_ptr&lt; ARDOUR::AudioBackend &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::AudioBackend::*)() const">buffer_size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioBackend::*)() const">device_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioBackend::*)() const">driver_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> override this if this implementation returns true from requires_driver_selection()</p></div></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (ARDOUR::AudioBackend::*)() const">dsp_load</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> return the fraction of the time represented by the current buffer size that is being used for each buffer process cycle, as a value from 0.0 to 1.0</p><p> E.g. if the buffer size represents 5msec and current processing takes 1msec, the returned value should be 0.2.</p><p> Implementations can feel free to smooth the values returned over time (e.g. high pass filtering, or its equivalent).</p></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DeviceStatusVector">DeviceStatusVector</a></td><td class="decl"><span class="functionname"><abbr title="std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt; (ARDOUR::AudioBackend::*)() const">enumerate_devices</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Returns a collection of DeviceStatuses identifying devices discovered by this backend since the start of the process.</p><p> Any of the names in each DeviceStatus may be used to identify a device in other calls to the backend, though any of them may become invalid at any time.</p></div></td></tr>
 <tr><td class="def"><a class="" href="#C:StringVector">StringVector</a></td><td class="decl"><span class="functionname"><abbr title="std::vector&lt;std::string &gt; (ARDOUR::AudioBackend::*)() const">enumerate_drivers</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> If the return value of requires_driver_selection() is true, then this function can return the list of known driver names.</p><p> If the return value of requires_driver_selection() is false, then this function should not be called. If it is called its return value is an empty vector of strings.</p></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DeviceStatusVector">DeviceStatusVector</a></td><td class="decl"><span class="functionname"><abbr title="std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt; (ARDOUR::AudioBackend::*)() const">enumerate_input_devices</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Returns a collection of DeviceStatuses identifying input devices discovered by this backend since the start of the process.</p><p> Any of the names in each DeviceStatus may be used to identify a device in other calls to the backend, though any of them may become invalid at any time.</p></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DeviceStatusVector">DeviceStatusVector</a></td><td class="decl"><span class="functionname"><abbr title="std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt; (ARDOUR::AudioBackend::*)() const">enumerate_output_devices</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Returns a collection of DeviceStatuses identifying output devices discovered by this backend since the start of the process.</p><p> Any of the names in each DeviceStatus may be used to identify a device in other calls to the backend, though any of them may become invalid at any time.</p></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AudioBackendInfo">AudioBackendInfo</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AudioBackendInfo&amp; (ARDOUR::AudioBackend::*)() const">info</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Return the AudioBackendInfo object from which this backend	was constructed.</p></div></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::AudioBackend::*)() const">input_channels</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioBackend::*)() const">input_device_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::AudioBackend::*)() const">output_channels</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioBackend::*)() const">output_device_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::AudioBackend::*)() const">period_size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (ARDOUR::AudioBackend::*)() const">sample_rate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(unsigned int)">set_buffer_size</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the buffer size to be used.</p><p> The device is assumed to use a double buffering scheme, so that one buffer&#39;s worth of data can be processed by hardware while software works on the other buffer. All known suitable audio APIs support this model (though ALSA allows for alternate numbers of buffers, and CoreAudio doesn&#39;t directly expose the concept).</p></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(std::string const&amp;)">set_device_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the name of the device to be used</p></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(std::string const&amp;)">set_driver</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Returns zero if the backend can successfully use </p><p> Should not be used unless the backend returns true from requires_driver_selection()</p><dl><dt class="param-name-index-invalid">name</dt><dd class="param-descr-index-invalid"> as the driver, non-zero otherwise.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(std::string const&amp;)">set_input_device_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the name of the input device to be used if using separate input&#47;output devices.</p><p> use_separate_input_and_output_devices()</p></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(std::string const&amp;)">set_output_device_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the name of the output device to be used if using separate input&#47;output devices.</p><p> use_separate_input_and_output_devices()</p></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(unsigned int)">set_peridod_size</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the period size to be used. must be called before starting the backend.</p></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioBackend::*)(float)">set_sample_rate</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the sample rate to be used</p></div></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::AudioBackend::*)() const">use_separate_input_and_output_devices</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> An optional alternate interface for backends to provide a facility to select separate input and output devices.</p><p> If a backend returns true then enumerate_input_devices() and enumerate_output_devices() will be used instead of enumerate_devices() to enumerate devices. Similarly set_input&#47;output_device_name() should be used to set devices instead of set_device_name().</p></div></td></tr>
 </table>
<h3 id="ARDOUR:AudioBackendInfo" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:AudioBackendInfo</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::AudioBackendInfo</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">char*</span></td><td class="decl"><span class="functionname">name</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:AudioBuffer" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:AudioBuffer</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::AudioBuffer</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Buffer containing audio data. </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AudioBuffer::*)(float, long)">apply_gain</abbr></span><span class="functionargs"> (<span class="em">float</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::AudioBuffer::*)(unsigned int, unsigned int&amp;) const">check_silence</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">unsigned int&amp;</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> check buffer for silence </p><dl><dt class="param-name-index-0">nframes</dt><dd class="param-descr-index-0">  number of frames to check </dd><dt class="param-name-index-1">n</dt><dd class="param-descr-index-1"> first non zero sample (if any) </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  true if all samples are zero</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#C:FloatArray">FloatArray</a></td><td class="decl"><span class="functionname"><abbr title="float* (ARDOUR::AudioBuffer::*)(long)">data</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AudioBuffer::*)(float const*, long, long, long)">read_from</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">long</span>, <span class="em">long</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AudioBuffer::*)(long, long)">silence</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> silence buffer </p><dl><dt class="param-name-index-0">len</dt><dd class="param-descr-index-0"> number of samples to clear </dd><dt class="param-name-index-1">offset</dt><dd class="param-descr-index-1"> start offset</dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:AudioEngine" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:AudioEngine</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::AudioEngine</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:BackendVector">BackendVector</a></td><td class="decl"><span class="functionname"><abbr title="std::vector&lt;ARDOUR::AudioBackendInfo const* &gt; (ARDOUR::AudioEngine::*)() const">available_backends</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioEngine::*)() const">current_backend_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (ARDOUR::AudioEngine::*)() const">get_dsp_load</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::AudioEngine::*)() const">get_last_backend_error</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AudioBackend">AudioBackend</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AudioBackend&gt; (ARDOUR::AudioEngine::*)(std::string const&amp;, std::string const&amp;, std::string const&amp;)">set_backend</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">std::string</span>, <span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioEngine::*)(unsigned int)">set_buffer_size</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioEngine::*)(std::string const&amp;)">set_device_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioEngine::*)(float)">set_sample_rate</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::AudioEngine::*)() const">setup_required</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioEngine::*)(bool)">start</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::AudioEngine::*)(bool)">stop</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:AudioSource" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:AudioSource</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::AudioSource &gt;, boost::weak_ptr&lt; ARDOUR::AudioSource &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Source">ARDOUR:Source</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::AudioSource::*)() const">n_channels</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::AudioSource::*)() const">readable_length</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:AudioTrack" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:AudioTrack</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::AudioTrack &gt;, boost::weak_ptr&lt; ARDOUR::AudioTrack &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Track">ARDOUR:Track</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:Track</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)()">can_record</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_enabled</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_safe</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)(std::string const&amp;)">set_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_enabled</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_safe</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:Route</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, int, ARDOUR::Route::ProcessorStreams*, bool)">add_processor_by_index</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">int</span>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">add_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Route::*)()">comment</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, unsigned int, ARDOUR::ChanCount)">customize_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanCount">ChanCount</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_inputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_outputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (ARDOUR::Route::*)(unsigned int) const">nth_plugin</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*, bool)">remove_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">remove_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*)">replace_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">reset_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(bool, void*)">set_active</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(std::string, void*)">set_comment</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(bool)">set_strict_io</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">strict_io</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:AudioTrackList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:AudioTrackList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.AudioTrackList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<a class="" href="#ARDOUR:AudioTrack">AudioTrack</a>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;::*)(boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; const&amp;)">push_back</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:AudioTrack">AudioTrack</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::AudioTrack&gt; &gt;::*)()">unique</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Automatable" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Automatable</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Automatable &gt;, boost::weak_ptr&lt; ARDOUR::Automatable &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#Evoral:ControlSet">Evoral:ControlSet</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AutomationControl">AutomationControl</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AutomationControl&gt; (ARDOUR::Automatable::*)(Evoral::Parameter const&amp;, bool)">automation_control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:AutomationControl" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:AutomationControl</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::AutomationControl &gt;, boost::weak_ptr&lt; ARDOUR::AutomationControl &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#Evoral:Control">Evoral:Control</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR.AutoState">AutoState</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AutoState (ARDOUR::AutomationControl::*)() const">automation_state</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::AutomationControl::*)() const">get_value</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Get the current effective `user&#39; value based on automation state </p></div></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(ARDOUR::AutoStyle)">set_automation_style</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR.AutoStyle">AutoStyle</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(double, PBD::Controllable::GroupControlDisposition)">set_value</abbr></span><span class="functionargs"> (<span class="em">double</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Get and Set `internal&#39; value</p><p> All derived classes must implement this.</p><p> Basic derived classes will ignore </p><dl><dt class="param-name-index-invalid">group_override,</dt><dd class="param-descr-index-invalid"> but more sophisticated children, notably those that proxy the value setting logic via an object that is aware of group relationships between this control and others, will find it useful.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(double)">start_touch</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(bool, double)">stop_touch</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::AutomationControl::*)() const">writable</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from Evoral:Control</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#Evoral:ControlList">ControlList</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::ControlList&gt; (Evoral::Control::*)()">list</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:BackendVector" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:BackendVector</h3>
<p class="cdecl"><em>C&#8225;</em>: std::vector&lt;ARDOUR::AudioBackendInfo const* &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.BackendVector</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">ARDOUR::AudioBackendInfo* </span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AudioBackendInfo">AudioBackendInfo</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AudioBackendInfo const*&amp; (std::vector&lt;ARDOUR::AudioBackendInfo const* &gt;::*)(unsigned long)">at</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::vector&lt;ARDOUR::AudioBackendInfo const* &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::vector&lt;ARDOUR::AudioBackendInfo const* &gt;::*)(ARDOUR::AudioBackendInfo const* const&amp;)">push_back</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:AudioBackendInfo">AudioBackendInfo</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::vector&lt;ARDOUR::AudioBackendInfo const* &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:BufferSet" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:BufferSet</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::BufferSet</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A set of buffers of various types.</p><p> These are mainly accessed from Session and passed around as scratch buffers (eg as parameters to run() methods) to do in-place signal processing.</p><p> There are two types of counts associated with a BufferSet - available, and the &#39;use count&#39;.  Available is the actual number of allocated buffers (and so is the maximum acceptable value for the use counts).</p><p> The use counts are how things determine the form of their input and inform others the form of their output (eg what they did to the BufferSet). Setting the use counts is realtime safe.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount const&amp; (ARDOUR::BufferSet::*)() const">count</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AudioBuffer">AudioBuffer</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AudioBuffer&amp; (ARDOUR::BufferSet::*)(unsigned long)">get_audio</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:ChanCount" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:ChanCount</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::ChanCount</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A count of channels, possibly with many types.</p><p> Operators are defined so this may safely be used as if it were a simple (single-typed) integer count of channels.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.ChanCount</span><span class="functionargs"> (<a class="" href="#ARDOUR:DataType">DataType</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Convenience constructor for making single-typed streams (mono, stereo, midi, etc) </p><dl><dt class="param-name-index-0">type</dt><dd class="param-descr-index-0"> data type </dd><dt class="param-name-index-1">count</dt><dd class="param-descr-index-1"> number of channels</dd></dl></div></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::ChanCount::*)(ARDOUR::DataType) const">get</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:DataType">DataType</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> query channel count for given type </p><dl><dt class="param-name-index-invalid">type</dt><dd class="param-descr-index-invalid"> data type </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  channel count for given type</p></div></div></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::ChanCount::*)() const">n_audio</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> query number of audio channels </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  number of audio channels</p></div></div></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::ChanCount::*)() const">n_midi</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> query number of midi channels </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  number of midi channels</p></div></div></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::ChanCount::*)() const">n_total</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> query total channel count of all data types </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  total channel count (audio + midi)</p></div></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::ChanCount::*)()">reset</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> zero count of all data types </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::ChanCount::*)(ARDOUR::DataType, unsigned int)">set</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:DataType">DataType</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> set channel count for given type </p><dl><dt class="param-name-index-1">count</dt><dd class="param-descr-index-1"> number of channels</dd><dt class="param-name-index-invalid">type</dt><dd class="param-descr-index-invalid"> data type </dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:ChanMapping" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:ChanMapping</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::ChanMapping</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A mapping from one set of channels to another. The general form is  1 source (from), many sinks (to). numeric IDs are used to identify sources and sinks.</p><p> for plugins this is used to map &quot;plugin-pin&quot; to &quot;audio-buffer&quot;</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.ChanMapping</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::ChanMapping::*)(ARDOUR::DataType, unsigned int) const">get</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:DataType">DataType</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> get buffer mapping for given data type and pin </p><dl><dt class="param-name-index-1">from</dt><dd class="param-descr-index-1"> numeric source id </dd><dt class="param-name-index-invalid">type</dt><dd class="param-descr-index-invalid"> data type </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  mapped buffer number (or ChanMapping::Invalid)</p></div></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::ChanMapping::*)(ARDOUR::DataType, unsigned int, unsigned int)">set</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:DataType">DataType</a>, <span class="em">unsigned int</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> set buffer mapping for given data type </p><dl><dt class="param-name-index-1">from</dt><dd class="param-descr-index-1"> numeric source id </dd><dt class="param-name-index-2">to</dt><dd class="param-descr-index-2"> buffer</dd><dt class="param-name-index-invalid">type</dt><dd class="param-descr-index-invalid"> data type </dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:DSP" class="cls freeclass"><abbr title="Namespace">&Nopf;</abbr>&nbsp;ARDOUR.DSP</h3>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float)">accurate_coefficient_to_dB</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, unsigned int, float)">apply_gain_to_buffer</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float const*, unsigned int, float)">compute_peak</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float const*, unsigned int)">copy_vector</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float)">dB_to_coefficient</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float)">fast_coefficient_to_dB</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float const*, unsigned int, float*, float*)">find_peaks</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>, <a class="" href="#C:FloatArray">FloatArray</a>, <a class="" href="#C:FloatArray">FloatArray</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float)">log_meter</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> non-linear power-scale meter deflection</p><dl><dt class="param-name-index-0">power</dt><dd class="param-descr-index-0"> signal power (dB) </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  deflected value</p></div></div></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (*)(float)">log_meter_coeff</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> non-linear power-scale meter deflection</p><dl><dt class="param-name-index-0">coeff</dt><dd class="param-descr-index-0"> signal value </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  deflected value</p></div></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float, unsigned int)">memset</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">float</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> lua wrapper to memset() </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float const*, unsigned int)">mix_buffers_no_gain</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float const*, unsigned int, float)">mix_buffers_with_gain</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float*, unsigned int)">mmult</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> matrix multiply multiply every sample of `data&#39; with the corresponding sample at `mult&#39;.</p><dl><dt class="param-name-index-0">data</dt><dd class="param-descr-index-0"> multiplicand </dd><dt class="param-name-index-1">mult</dt><dd class="param-descr-index-1"> multiplicand </dd><dt class="param-name-index-2">n_samples</dt><dd class="param-descr-index-2"> number of samples in data and mmult</dd></dl></div></td></tr>
 <tr><td class="def"><em>LuaTable</em>(...)</td><td class="decl"><span class="functionname"><abbr title="void (*)(float*, float&amp;, float&amp;, unsigned int)">peaks</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">float&amp;</span>, <span class="em">float&amp;</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> calculate peaks</p><dl><dt class="param-name-index-0">data</dt><dd class="param-descr-index-0"> data to analyze </dd><dt class="param-name-index-1">min</dt><dd class="param-descr-index-1"> result, minimum value found in range </dd><dt class="param-name-index-2">max</dt><dd class="param-descr-index-2"> result, max value found in range </dd><dt class="param-name-index-3">n_samples</dt><dd class="param-descr-index-3"> number of samples to analyze</dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:DSP:Biquad" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DSP:Biquad</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::DSP::BiQuad</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Biquad Filter </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.DSP.Biquad</span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::BiQuad::*)(ARDOUR::DSP::BiQuad::Type, double, double, double)">compute</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR.DSP.BiQuad.Type">Type</a>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> setup filter, compute coefficients</p><dl><dt class="param-name-index-0">t</dt><dd class="param-descr-index-0"> filter type (LowPass, HighPass, etc) </dd><dt class="param-name-index-1">freq</dt><dd class="param-descr-index-1"> filter frequency </dd><dt class="param-name-index-2">Q</dt><dd class="param-descr-index-2"> filter quality </dd><dt class="param-name-index-3">gain</dt><dd class="param-descr-index-3"> filter gain</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::BiQuad::*)()">reset</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> reset filter state </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::BiQuad::*)(float*, unsigned int)">run</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> process audio data</p><dl><dt class="param-name-index-0">data</dt><dd class="param-descr-index-0"> pointer to audio-data </dd><dt class="param-name-index-1">n_samples</dt><dd class="param-descr-index-1"> number of samples to process</dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:DSP:DspShm" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DSP:DspShm</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::DSP::DspShm</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> C&#47;C++ Shared Memory</p><p> A convenience class representing a C array of float[] or int32_t[] data values. This is useful for lua scripts to perform DSP operations directly using C&#47;C++ with CPU Hardware acceleration.</p><p> Access to this memory area is always 4 byte aligned. The data is interpreted either as float or as int.</p><p> This memory area can also be shared between different instances or the same lua plugin (DSP, GUI).</p><p> Since memory allocation is not realtime safe it should be allocated during dsp_init() or dsp_configure(). The memory is free()ed automatically when the lua instance is destroyed.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::DspShm::*)(unsigned long)">allocate</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> [re] allocate memory in host&#39;s memory space</p><dl><dt class="param-name-index-0">s</dt><dd class="param-descr-index-0"> size, total number of float or integer elements to store.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::DSP::DspShm::*)(unsigned long)">atomic_get_int</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> atomically read integer at offset</p><p> This involves a memory barrier. This call is intended for buffers which are shared with another instance.</p><dl><dt class="param-name-index-0">off</dt><dd class="param-descr-index-0"> offset in shared memory region </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  value at offset</p></div></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::DspShm::*)(unsigned long, int)">atomic_set_int</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>, <span class="em">int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> atomically set integer at offset</p><p> This involves a memory barrier. This call is intended for buffers which are shared with another instance.</p><dl><dt class="param-name-index-0">off</dt><dd class="param-descr-index-0"> offset in shared memory region </dd><dt class="param-name-index-1">val</dt><dd class="param-descr-index-1"> value to set</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::DspShm::*)()">clear</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> clear memory (set to zero) </p></div></td></tr>
 <tr><td class="def"><a class="" href="#C:FloatArray">FloatArray</a></td><td class="decl"><span class="functionname"><abbr title="float* (ARDOUR::DSP::DspShm::*)(unsigned long)">to_float</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> access memory as float array</p><dl><dt class="param-name-index-0">off</dt><dd class="param-descr-index-0"> offset in shared memory region </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  float[]</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#C:IntArray">IntArray</a></td><td class="decl"><span class="functionname"><abbr title="int* (ARDOUR::DSP::DspShm::*)(unsigned long)">to_int</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> access memory as integer array</p><dl><dt class="param-name-index-0">off</dt><dd class="param-descr-index-0"> offset in shared memory region </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  int_32_t[]</p></div></div></td></tr>
 </table>
<h3 id="ARDOUR:DSP:LowPass" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DSP:LowPass</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::DSP::LowPass</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> 1st order Low Pass filter </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.DSP.LowPass</span><span class="functionargs"> (<span class="em">double</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> instantiate a LPF</p><dl><dt class="param-name-index-0">samplerate</dt><dd class="param-descr-index-0"> samplerate </dd><dt class="param-name-index-1">freq</dt><dd class="param-descr-index-1"> cut-off frequency</dd></dl></div></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::LowPass::*)(float*, float, unsigned int)">ctrl</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">float</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> filter control data</p><p> This is useful for parameter smoothing.</p><dl><dt class="param-name-index-0">data</dt><dd class="param-descr-index-0"> pointer to control-data array </dd><dt class="param-name-index-1">val</dt><dd class="param-descr-index-1"> target value </dd><dt class="param-name-index-invalid">array</dt><dd class="param-descr-index-invalid"> length</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::LowPass::*)(float*, unsigned int)">proc</abbr></span><span class="functionargs"> (<a class="" href="#C:FloatArray">FloatArray</a>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> process audio data</p><dl><dt class="param-name-index-0">data</dt><dd class="param-descr-index-0"> pointer to audio-data </dd><dt class="param-name-index-1">n_samples</dt><dd class="param-descr-index-1"> number of samples to process</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::LowPass::*)()">reset</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> reset filter state </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::DSP::LowPass::*)(float)">set_cutoff</abbr></span><span class="functionargs"> (<span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> update filter cut-off frequency</p><dl><dt class="param-name-index-0">freq</dt><dd class="param-descr-index-0"> cut-off frequency</dd></dl></div></td></tr>
 </table>
<h3 id="ARDOUR:DataType" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DataType</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::DataType</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A type of Data Ardour is capable of processing.</p><p> The majority of this class is dedicated to conversion to and from various other type representations, simple comparison between then, etc.  This code is deliberately &#39;ugly&#39; so other code doesn&#39;t have to be.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.DataType</span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DataType">DataType</a></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">audio</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> convenience contructor for DataType::AUDIO </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  DataType::AUDIO</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DataType">DataType</a></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">midi</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> convenience contructor for DataType::MIDI </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  DataType::MIDI</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DataType">DataType</a></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">null</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> convenience contructor for DataType::NIL </p><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  DataType::NIL</p></div></div></td></tr>
 </table>
<h3 id="ARDOUR:DeviceStatus" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DeviceStatus</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::AudioBackend::DeviceStatus</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> used to list device names along with whether or not they are currently  available.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">available</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname">name</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:DeviceStatusVector" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:DeviceStatusVector</h3>
<p class="cdecl"><em>C&#8225;</em>: std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.DeviceStatusVector</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<a class="" href="#ARDOUR:DeviceStatus">DeviceStatus</a>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DeviceStatus">DeviceStatus</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AudioBackend::DeviceStatus&amp; (std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt;::*)(unsigned long)">at</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt;::*)(ARDOUR::AudioBackend::DeviceStatus const&amp;)">push_back</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:DeviceStatus">DeviceStatus</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::vector&lt;ARDOUR::AudioBackend::DeviceStatus &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:IO" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:IO</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::IO &gt;, boost::weak_ptr&lt; ARDOUR::IO &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:SessionObject">ARDOUR:SessionObject</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::IO::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::IO::*)(std::string, void*, ARDOUR::DataType)">add_port</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">void*</span>, <a class="" href="#ARDOUR:DataType">DataType</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Add a port.</p><dl><dt class="param-name-index-0">destination</dt><dd class="param-descr-index-0"> Name of port to connect new port to. </dd><dt class="param-name-index-1">src</dt><dd class="param-descr-index-1"> Source for emitted ConfigurationChanged signal. </dd><dt class="param-name-index-2">type</dt><dd class="param-descr-index-2"> Data type of port.  Default value (NIL) will use this IO&#39;s default type.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::IO::*)(boost::shared_ptr&lt;ARDOUR::Port&gt;, std::string, void*)">connect</abbr></span><span class="functionargs"> (<span class="em">--MISSING (boost::shared_ptr&lt;ARDOUR::Port&gt;)--</span>, <span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::IO::*)(boost::shared_ptr&lt;ARDOUR::Port&gt;, std::string, void*)">disconnect</abbr></span><span class="functionargs"> (<span class="em">--MISSING (boost::shared_ptr&lt;ARDOUR::Port&gt;)--</span>, <span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::IO::*)() const">physically_connected</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::IO::*)(boost::shared_ptr&lt;ARDOUR::Port&gt;, void*)">remove_port</abbr></span><span class="functionargs"> (<span class="em">--MISSING (boost::shared_ptr&lt;ARDOUR::Port&gt;)--</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:IOProcessor" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:IOProcessor</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::IOProcessor &gt;, boost::weak_ptr&lt; ARDOUR::IOProcessor &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Processor">ARDOUR:Processor</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IO">IO</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::IO&gt; (ARDOUR::IOProcessor::*)()">input</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::IOProcessor::*)() const">natural_input_streams</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::IOProcessor::*)() const">natural_output_streams</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IO">IO</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::IO&gt; (ARDOUR::IOProcessor::*)()">output</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:Processor</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">activate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Processor::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AutomationControl">AutomationControl</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AutomationControl&gt; (ARDOUR::Automatable::*)(Evoral::Parameter const&amp;, bool)">automation_control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Evoral:Control">Control</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::Control&gt; (Evoral::ControlSet::*)(Evoral::Parameter const&amp;, bool)">control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">deactivate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Processor::*)() const">display_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PluginInsert">PluginInsert</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::PluginInsert (ARDOUR::Processor::*)()">to_insert</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IOProcessor">IOProcessor</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::IOProcessor (ARDOUR::Processor::*)()">to_ioprocessor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:SideChain">SideChain</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::SideChain (ARDOUR::Processor::*)()">to_sidechain</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:Location" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:Location</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Location</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:StatefulDestructible">PBD:StatefulDestructible</a></p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Location on Timeline - abstract representation for Markers, Loop&#47;Punch Ranges, CD-Markers etc. </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Location::*)() const">end</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Location::*)() const">length</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Location::*)()">lock</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Location::*)() const">locked</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Location::*)(long)">move_to</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Location::*)(long, bool, bool)">set_end</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set end position.  </p><dl><dt class="param-name-index-1">force</dt><dd class="param-descr-index-1"> true to force setting, even if the given new end is before the current start.  </dd><dt class="param-name-index-2">allow_bbt_recompute</dt><dd class="param-descr-index-2"> True to recompute BBT end time from the new given end time.</dd><dt class="param-name-index-invalid">s</dt><dd class="param-descr-index-invalid"> New end.  </dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Location::*)(long, long, bool)">set_length</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">long</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Location::*)(long, bool, bool)">set_start</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set start position.  </p><dl><dt class="param-name-index-0">s</dt><dd class="param-descr-index-0"> New start.  </dd><dt class="param-name-index-1">force</dt><dd class="param-descr-index-1"> true to force setting, even if the given new start is after the current end.  </dd><dt class="param-name-index-2">allow_bbt_recompute</dt><dd class="param-descr-index-2"> True to recompute BBT start time from the new given start time.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Location::*)() const">start</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from PBD:Stateful</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:LuaAPI" class="cls freeclass"><abbr title="Namespace">&Nopf;</abbr>&nbsp;ARDOUR.LuaAPI</h3>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (*)(ARDOUR::Session*, std::string const&amp;)">new_luaproc</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Session">Session</a>, <span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> create a new Lua Processor (Plugin)</p><dl><dt class="param-name-index-0">s</dt><dd class="param-descr-index-0"> Session Handle </dd><dt class="param-name-index-1">p</dt><dd class="param-descr-index-1"> Identifier or Name of the Processor </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  Processor object (may be nil)</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (*)(ARDOUR::Session*, std::string const&amp;, ARDOUR::PluginType, std::string const&amp;)">new_plugin</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Session">Session</a>, <span class="em">std::string</span>, <a class="" href="#ARDOUR.PluginType">PluginType</a>, <span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> create a new Plugin Instance</p><dl><dt class="param-name-index-0">s</dt><dd class="param-descr-index-0"> Session Handle </dd><dt class="param-name-index-1">id</dt><dd class="param-descr-index-1"> Plugin Name, ID or URI </dd><dt class="param-name-index-2">type</dt><dd class="param-descr-index-2"> Plugin Type </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  Processor or nil</p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PluginInfo">PluginInfo</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::PluginInfo&gt; (*)(std::string const&amp;, ARDOUR::PluginType)">new_plugin_info</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <a class="" href="#ARDOUR.PluginType">PluginType</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> search a Plugin</p><dl><dt class="param-name-index-0">id</dt><dd class="param-descr-index-0"> Plugin Name, ID or URI </dd><dt class="param-name-index-1">type</dt><dd class="param-descr-index-1"> Plugin Type </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  PluginInfo or nil if not found</p></div></div></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (*)(boost::shared_ptr&lt;ARDOUR::PluginInsert&gt;, unsigned int, float)">set_plugin_insert_param</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:PluginInsert">PluginInsert</a>, <span class="em">unsigned int</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> set a plugin control-input parameter value</p><p> This is a wrapper around set_processor_param which looks up the Processor by plugin-insert.</p><dl><dt class="param-name-index-1">which</dt><dd class="param-descr-index-1"> control-input to set (starting at 0) </dd><dt class="param-name-index-invalid">proc</dt><dd class="param-descr-index-invalid"> Plugin-Insert </dd><dt class="param-name-index-invalid">value</dt><dd class="param-descr-index-invalid"> value to set </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  true on success, false on error or out-of-bounds value</p></div></div></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, unsigned int, float)">set_processor_param</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">unsigned int</span>, <span class="em">float</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> set a plugin control-input parameter value</p><dl><dt class="param-name-index-0">proc</dt><dd class="param-descr-index-0"> Plugin-Processor </dd><dt class="param-name-index-1">which</dt><dd class="param-descr-index-1"> control-input to set (starting at 0) </dd><dt class="param-name-index-invalid">value</dt><dd class="param-descr-index-invalid"> value to set </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  true on success, false on error or out-of-bounds value</p></div></div></td></tr>
 </table>
<h3 id="ARDOUR:LuaOSC:Address" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:LuaOSC:Address</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::LuaOSC::Address</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> OSC transmitter</p><p> A Class to send OSC messages.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.LuaOSC.Address</span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Construct a new OSC transmitter object </p><dl><dt class="param-name-index-0">uri</dt><dd class="param-descr-index-0"> the destination uri e.g. &quot;osc.udp:&#47;&#47;localhost:7890&quot;</dd></dl></div></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>...</em></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::LuaOSC::Address::*)(lua_State*)">send</abbr></span><span class="functionargs"> (<span class="em">--lua--</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Transmit an OSC message</p><p> Path (string) and type (string) must always be given. The number of following args must match the type. Supported types are:</p><p>  &#39;i&#39;: integer (lua number)</p><p>  &#39;f&#39;: float (lua number)</p><p>  &#39;d&#39;: double (lua number)</p><p>  &#39;h&#39;: 64bit integer (lua number)</p><p>  &#39;s&#39;: string (lua string)</p><p>  &#39;c&#39;: character (lua string)</p><p>  &#39;T&#39;: boolean (lua bool) -- this is not implicily True, a lua true&#47;false must be given</p><p>  &#39;F&#39;: boolean (lua bool) -- this is not implicily False, a lua true&#47;false must be given</p><dl><dt class="param-name-index-invalid">lua:</dt><dd class="param-descr-index-invalid"> lua arguments: path, types, ... </dd></dl><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  boolean true if successful, false on error.</p></div></div></td></tr>
 </table>
<h3 id="ARDOUR:Meter" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:Meter</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Meter</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Meter, or time signature (beats per bar, and which note type is a beat). </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.Meter</span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Meter::*)() const">divisions_per_bar</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Meter::*)(ARDOUR::Tempo const&amp;, long) const">frames_per_bar</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Tempo">Tempo</a>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Meter::*)(ARDOUR::Tempo const&amp;, long) const">frames_per_grid</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Tempo">Tempo</a>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Meter::*)() const">note_divisor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:MidiBuffer" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:MidiBuffer</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::MidiBuffer</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Buffer containing 8-bit unsigned char (MIDI) data. </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::MidiBuffer::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::MidiBuffer::*)(long, long)">silence</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Clear (eg zero, or empty) buffer </p></div></td></tr>
 </table>
<h3 id="ARDOUR:MidiTrack" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:MidiTrack</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::MidiTrack &gt;, boost::weak_ptr&lt; ARDOUR::MidiTrack &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Track">ARDOUR:Track</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:Track</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)()">can_record</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_enabled</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_safe</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)(std::string const&amp;)">set_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_enabled</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_safe</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:Route</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, int, ARDOUR::Route::ProcessorStreams*, bool)">add_processor_by_index</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">int</span>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">add_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Route::*)()">comment</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, unsigned int, ARDOUR::ChanCount)">customize_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanCount">ChanCount</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_inputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_outputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (ARDOUR::Route::*)(unsigned int) const">nth_plugin</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*, bool)">remove_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">remove_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*)">replace_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">reset_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(bool, void*)">set_active</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(std::string, void*)">set_comment</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(bool)">set_strict_io</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">strict_io</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:MidiTrackList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:MidiTrackList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.MidiTrackList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<a class="" href="#ARDOUR:MidiTrack">MidiTrack</a>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;::*)(boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; const&amp;)">push_back</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:MidiTrack">MidiTrack</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::MidiTrack&gt; &gt;::*)()">unique</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:OwnedPropertyList" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ARDOUR:OwnedPropertyList</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::OwnedPropertyList</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:PropertyList">ARDOUR:PropertyList</a></p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A variant of PropertyList that does not delete its  property list in its destructor. Objects with their  own Properties store them in an OwnedPropertyList  to avoid having them deleted at the wrong time.</p></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ARDOUR:ParameterDescriptor" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:ParameterDescriptor</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::ParameterDescriptor</p>
 <p class="classinfo">is-a: <a class="" href="#Evoral:ParameterDescriptor">Evoral:ParameterDescriptor</a></p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Descriptor of a parameter or control.</p><p> Essentially a union of LADSPA, VST and LV2 info.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.ParameterDescriptor</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname">label</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">logarithmic</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from Evoral:ParameterDescriptor</h4>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">Evoral.ParameterDescriptor</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">lower</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">normal</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">toggled</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">upper</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:Plugin" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Plugin</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Plugin &gt;, boost::weak_ptr&lt; ARDOUR::Plugin &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:StatefulDestructiblePtr">PBD:StatefulDestructiblePtr</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Plugin::*)() const">get_docs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<span class="em">int</span>, ...)</td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Plugin::*)(unsigned int, ARDOUR::ParameterDescriptor&amp;) const">get_parameter_descriptor</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ParameterDescriptor">ParameterDescriptor&amp;</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Plugin::*)(unsigned int) const">get_parameter_docs</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">char*</span></td><td class="decl"><span class="functionname"><abbr title="char const* (ARDOUR::Plugin::*)() const">label</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Plugin::*)(ARDOUR::Plugin::PresetRecord)">load_preset</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:PresetRecord">PresetRecord</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set parameters using a preset </p></div></td></tr>
 <tr><td class="def"><span class="em">char*</span></td><td class="decl"><span class="functionname"><abbr title="char const* (ARDOUR::Plugin::*)() const">maker</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">char*</span></td><td class="decl"><span class="functionname"><abbr title="char const* (ARDOUR::Plugin::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<span class="em">unsigned int</span>, ...)</td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::Plugin::*)(unsigned int, bool&amp;) const">nth_parameter</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">bool&amp;</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::Plugin::*)() const">parameter_count</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Plugin::*)(unsigned int) const">parameter_is_input</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PresetRecord">PresetRecord</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::Plugin::PresetRecord const* (ARDOUR::Plugin::*)(std::string const&amp;)">preset_by_label</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PresetRecord">PresetRecord</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::Plugin::PresetRecord const* (ARDOUR::Plugin::*)(std::string const&amp;)">preset_by_uri</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:PluginControl" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:PluginControl</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::PluginInsert::PluginControl &gt;, boost::weak_ptr&lt; ARDOUR::PluginInsert::PluginControl &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:AutomationControl">ARDOUR:AutomationControl</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:AutomationControl</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR.AutoState">AutoState</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::AutoState (ARDOUR::AutomationControl::*)() const">automation_state</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::AutomationControl::*)() const">get_value</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Get the current effective `user&#39; value based on automation state </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(ARDOUR::AutoStyle)">set_automation_style</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR.AutoStyle">AutoStyle</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(double, PBD::Controllable::GroupControlDisposition)">set_value</abbr></span><span class="functionargs"> (<span class="em">double</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Get and Set `internal&#39; value</p><p> All derived classes must implement this.</p><p> Basic derived classes will ignore </p><dl><dt class="param-name-index-invalid">group_override,</dt><dd class="param-descr-index-invalid"> but more sophisticated children, notably those that proxy the value setting logic via an object that is aware of group relationships between this control and others, will find it useful.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(double)">start_touch</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::AutomationControl::*)(bool, double)">stop_touch</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::AutomationControl::*)() const">writable</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from Evoral:Control</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#Evoral:ControlList">ControlList</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::ControlList&gt; (Evoral::Control::*)()">list</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:PluginInfo" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:PluginInfo</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::PluginInfo &gt;, boost::weak_ptr&lt; ARDOUR::PluginInfo &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.PluginInfo</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:PluginInsert" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:PluginInsert</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::PluginInsert &gt;, boost::weak_ptr&lt; ARDOUR::PluginInsert &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Processor">ARDOUR:Processor</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::PluginInsert::*)()">activate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::PluginInsert::*)()">deactivate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanMapping">ChanMapping</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanMapping (ARDOUR::PluginInsert::*)(unsigned int) const">input_map</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanMapping">ChanMapping</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanMapping (ARDOUR::PluginInsert::*)(unsigned int) const">output_map</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Plugin">Plugin</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Plugin&gt; (ARDOUR::PluginInsert::*)(unsigned int) const">plugin</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::PluginInsert::*)(unsigned int, ARDOUR::ChanMapping)">set_input_map</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanMapping">ChanMapping</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::PluginInsert::*)(unsigned int, ARDOUR::ChanMapping)">set_output_map</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanMapping">ChanMapping</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::PluginInsert::*)() const">strict_io_configured</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:Processor</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Processor::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AutomationControl">AutomationControl</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AutomationControl&gt; (ARDOUR::Automatable::*)(Evoral::Parameter const&amp;, bool)">automation_control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Evoral:Control">Control</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::Control&gt; (Evoral::ControlSet::*)(Evoral::Parameter const&amp;, bool)">control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Processor::*)() const">display_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PluginInsert">PluginInsert</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::PluginInsert (ARDOUR::Processor::*)()">to_insert</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IOProcessor">IOProcessor</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::IOProcessor (ARDOUR::Processor::*)()">to_ioprocessor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:SideChain">SideChain</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::SideChain (ARDOUR::Processor::*)()">to_sidechain</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:PresetRecord" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:PresetRecord</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Plugin::PresetRecord</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname">label</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname">uri</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">user</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">valid</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Processor" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Processor</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Processor &gt;, boost::weak_ptr&lt; ARDOUR::Processor &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Automatable">ARDOUR:Automatable</a>, <a class="" href="#ARDOUR:SessionObject">ARDOUR:SessionObject</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">activate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Processor::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AutomationControl">AutomationControl</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AutomationControl&gt; (ARDOUR::Automatable::*)(Evoral::Parameter const&amp;, bool)">automation_control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Evoral:Control">Control</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::Control&gt; (Evoral::ControlSet::*)(Evoral::Parameter const&amp;, bool)">control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">deactivate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Processor::*)() const">display_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PluginInsert">PluginInsert</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::PluginInsert (ARDOUR::Processor::*)()">to_insert</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IOProcessor">IOProcessor</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::IOProcessor (ARDOUR::Processor::*)()">to_ioprocessor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:SideChain">SideChain</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::SideChain (ARDOUR::Processor::*)()">to_sidechain</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:Properties:BoolProperty" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ARDOUR:Properties:BoolProperty</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::PropertyDescriptor&lt;bool&gt;</p>
<div class="clear"></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ARDOUR:Properties:FloatProperty" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ARDOUR:Properties:FloatProperty</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::PropertyDescriptor&lt;float&gt;</p>
<div class="clear"></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ARDOUR:Properties:FrameposProperty" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ARDOUR:Properties:FrameposProperty</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::PropertyDescriptor&lt;long&gt;</p>
<div class="clear"></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ARDOUR:PropertyChange" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:PropertyChange</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::PropertyChange</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A list of IDs of Properties that have changed in some situation or other </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PBD::PropertyChange::*)(PBD::PropertyDescriptor&lt;bool&gt;) const">containsBool</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Properties:BoolProperty">BoolProperty</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PBD::PropertyChange::*)(PBD::PropertyDescriptor&lt;float&gt;) const">containsFloat</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Properties:FloatProperty">FloatProperty</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PBD::PropertyChange::*)(PBD::PropertyDescriptor&lt;long&gt;) const">containsFramePos</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Properties:FrameposProperty">FrameposProperty</a>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:PropertyList" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ARDOUR:PropertyList</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::PropertyList</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A list of properties, mapped using their ID </p></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ARDOUR:Region" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Region</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Region &gt;, boost::weak_ptr&lt; ARDOUR::Region &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:SessionObject">ARDOUR:SessionObject</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">at_natural_position</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">automatic</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">can_move</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">captured</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">clear_sync_position</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)(long) const">covers</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">cut_end</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">cut_front</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:DataType">DataType</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::DataType const&amp; (ARDOUR::Region::*)() const">data_type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">external</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">hidden</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">import</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">is_compound</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (ARDOUR::Region::*)() const">layer</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Region::*)() const">length</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">locked</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">lower</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">lower_to_bottom</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">move_start</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">move_to_natural_position</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">muted</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">nudge_position</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">opaque</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Region::*)() const">position</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> How the region parameters play together:</p><p> POSITION: first frame of the region along the timeline START:    first frame of the region within its source(s) LENGTH:   number of frames the region represents</p></div></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">position_locked</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">raise</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)()">raise_to_top</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_hidden</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">set_initial_position</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A gui may need to create a region, then place it in an initial  position determined by the user.  When this takes place within one gui operation, we have to reset  _last_position to prevent an implied move.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">set_length</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_locked</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_muted</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_opaque</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">set_position</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_position_locked</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">set_start</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">set_sync_position</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the region&#39;s sync point.  </p><dl><dt class="param-name-index-0">absolute_pos</dt><dd class="param-descr-index-0"> Session time.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(bool)">set_video_locked</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (ARDOUR::Region::*)() const">shift</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Region::*)() const">start</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname"><abbr title="float (ARDOUR::Region::*)() const">stretch</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">sync_marked</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<span class="em">long</span>, ...)</td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Region::*)(int&amp;) const">sync_offset</abbr></span><span class="functionargs"> (<span class="em">int&amp;</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Region::*)() const">sync_position</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  Sync position in session time </p></div></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">trim_end</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><dl><dt class="param-name-index-0">new_endpoint</dt><dd class="param-descr-index-0"> New region end point, such that, for example,  a region at 0 of length 10 has an endpoint of 9.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long)">trim_front</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Region::*)(long, long)">trim_to</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">valid_transients</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">video_locked</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Region::*)() const">whole_file</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:RegionFactory" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:RegionFactory</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::RegionFactory</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Region">Region</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Region&gt; (*)(PBD::ID const&amp;)">region_by_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Route" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Route</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Route &gt;, boost::weak_ptr&lt; ARDOUR::Route &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:SessionObject">ARDOUR:SessionObject</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, int, ARDOUR::Route::ProcessorStreams*, bool)">add_processor_by_index</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">int</span>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">add_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Route::*)()">comment</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, unsigned int, ARDOUR::ChanCount)">customize_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanCount">ChanCount</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_inputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_outputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (ARDOUR::Route::*)(unsigned int) const">nth_plugin</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*, bool)">remove_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">remove_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*)">replace_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">reset_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(bool, void*)">set_active</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(std::string, void*)">set_comment</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(std::string const&amp;)">set_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(bool)">set_strict_io</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">strict_io</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:Route:ProcessorStreams" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:Route:ProcessorStreams</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Route::ProcessorStreams</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> A record of the stream configuration at some point in the processor list. Used to return where and why an processor list configuration request failed.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.Route.ProcessorStreams</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:RouteList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:RouteList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.RouteList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:RouteListPtr" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:RouteListPtr</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt;std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.RouteListPtr</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<a class="" href="#ARDOUR:Route">Route</a>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)(boost::shared_ptr&lt;ARDOUR::Route&gt; const&amp;)">push_back</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Route">Route</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt;::*)()">unique</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Session" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:Session</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Session</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Ardour Session </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Session::*)() const">actively_recording</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#PBD:Controllable">Controllable</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;PBD::Controllable&gt; (ARDOUR::Session::*)(PBD::ID const&amp;)">controllable_by_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">current_end_frame</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">current_start_frame</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">frame_rate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> &quot;actual&quot; sample rate of session, set by current audioengine rate, pullup&#47;down etc. </p></div></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Session::*)() const">frames_per_timecode_frame</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:RouteListPtr">RouteListPtr</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt; &gt; (ARDOUR::Session::*)() const">get_routes</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:BufferSet">BufferSet</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::BufferSet&amp; (ARDOUR::Session::*)(ARDOUR::ChanCount, bool)">get_scratch_buffers</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:ChanCount">ChanCount</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:BufferSet">BufferSet</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::BufferSet&amp; (ARDOUR::Session::*)(ARDOUR::ChanCount)">get_silent_buffers</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:ChanCount">ChanCount</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:RouteListPtr">RouteListPtr</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt; &gt; (ARDOUR::Session::*)() const">get_tracks</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)()">goto_end</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)()">goto_start</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">last_transport_start</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Session::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:RouteList">RouteList</a></td><td class="decl"><span class="functionname"><abbr title="std::list&lt;boost::shared_ptr&lt;ARDOUR::Route&gt; &gt; (ARDOUR::Session::*)(unsigned int, std::string const&amp;, std::string const&amp;, ARDOUR::PlaylistDisposition)">new_route_from_template</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">std::string</span>, <span class="em">std::string</span>, <a class="" href="#ARDOUR.PlaylistDisposition">PlaylistDisposition</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">nominal_frame_rate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> &quot;native&quot; sample rate of session, regardless of current audioengine rate, pullup&#47;down etc </p></div></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Session::*)() const">path</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (ARDOUR::Session::*)(PBD::ID) const">processor_by_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR.Session.RecordState">RecordState</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::Session::RecordState (ARDOUR::Session::*)() const">record_status</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)(long, bool)">request_locate</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)(bool, bool)">request_stop</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)(double, bool)">request_transport_speed</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Route">Route</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Route&gt; (ARDOUR::Session::*)(PBD::ID)">route_by_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Route">Route</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Route&gt; (ARDOUR::Session::*)(std::string)">route_by_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Route">Route</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Route&gt; (ARDOUR::Session::*)(unsigned int)">route_by_remote_id</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Session::*)(std::string, bool, bool, bool)">save_state</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">bool</span>, <span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><dl><dt class="param-name-index-0">snapshot_name</dt><dd class="param-descr-index-0"> Name to save under, without .ardour &#47; .pending prefix </dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)()">scripts_changed</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Session::*)()">set_dirty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Session::*)() const">snap_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Source">Source</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Source&gt; (ARDOUR::Session::*)(PBD::ID const&amp;)">source_by_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:TempoMap">TempoMap</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::TempoMap&amp; (ARDOUR::Session::*)()">tempo_map</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Session::*)() const">timecode_drop_frames</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">timecode_frames_per_hour</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Session::*)() const">timecode_frames_per_second</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Track">Track</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Track&gt; (ARDOUR::Session::*)(PBD::ID)">track_by_diskstream_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (ARDOUR::Session::*)() const">transport_frame</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Session::*)() const">transport_rolling</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Session::*)() const">transport_speed</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#C:StringList">StringList</a></td><td class="decl"><span class="functionname"><abbr title="std::list&lt;std::string &gt; (ARDOUR::Session::*)() const">unknown_processors</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:SessionObject" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:SessionObject</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::SessionObject &gt;, boost::weak_ptr&lt; ARDOUR::SessionObject &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:StatefulDestructiblePtr">PBD:StatefulDestructiblePtr</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:SideChain" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:SideChain</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::SideChain &gt;, boost::weak_ptr&lt; ARDOUR::SideChain &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:IOProcessor">ARDOUR:IOProcessor</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:IOProcessor</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IO">IO</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::IO&gt; (ARDOUR::IOProcessor::*)()">input</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::IOProcessor::*)() const">natural_input_streams</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::IOProcessor::*)() const">natural_output_streams</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IO">IO</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::IO&gt; (ARDOUR::IOProcessor::*)()">output</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:Processor</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">activate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Processor::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:AutomationControl">AutomationControl</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::AutomationControl&gt; (ARDOUR::Automatable::*)(Evoral::Parameter const&amp;, bool)">automation_control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Evoral:Control">Control</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::Control&gt; (Evoral::ControlSet::*)(Evoral::Parameter const&amp;, bool)">control</abbr></span><span class="functionargs"> (<a class="" href="#Evoral:Parameter">Parameter</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Processor::*)()">deactivate</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Processor::*)() const">display_name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:PluginInsert">PluginInsert</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::PluginInsert (ARDOUR::Processor::*)()">to_insert</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:IOProcessor">IOProcessor</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::IOProcessor (ARDOUR::Processor::*)()">to_ioprocessor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:SideChain">SideChain</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::SideChain (ARDOUR::Processor::*)()">to_sidechain</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:Source" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Source</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Source &gt;, boost::weak_ptr&lt; ARDOUR::Source &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Tempo" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:Tempo</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::Tempo</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Tempo, the speed at which musical time progresses (BPM). </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.Tempo</span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><dl><dt class="param-name-index-0">bpm</dt><dd class="param-descr-index-0"> Beats Per Minute </dd><dt class="param-name-index-1">type</dt><dd class="param-descr-index-1"> Note Type (default `4&#39;: quarter note)</dd></dl></div></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Tempo::*)() const">beats_per_minute</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Tempo::*)(long) const">frames_per_beat</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> audio samples per beat </p><dl><dt class="param-name-index-0">sr</dt><dd class="param-descr-index-0"> samplerate</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (ARDOUR::Tempo::*)() const">note_type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:TempoMap" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:TempoMap</h3>
<p class="cdecl"><em>C&#8225;</em>: ARDOUR::TempoMap</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Tempo Map - mapping of timecode to musical time. convert audio-samples, sample-rate to Bar&#47;Beat&#47;Tick, Meter&#47;Tempo</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::TempoMap::*)(ARDOUR::Meter const&amp;, Timecode::BBT_Time)">add_meter</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Meter">Meter</a>, <a class="" href="#Timecode:BBT_TIME">BBT_TIME</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::TempoMap::*)(ARDOUR::Tempo const&amp;, Timecode::BBT_Time)">add_tempo</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Tempo">Tempo</a>, <a class="" href="#Timecode:BBT_TIME">BBT_TIME</a>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:Track" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;ARDOUR:Track</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; ARDOUR::Track &gt;, boost::weak_ptr&lt; ARDOUR::Track &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#ARDOUR:Route">ARDOUR:Route</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)()">can_record</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_enabled</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)() const">record_safe</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Track::*)(std::string const&amp;)">set_name</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_enabled</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Track::*)(bool, PBD::Controllable::GroupControlDisposition)">set_record_safe</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <a class="" href="#PBD.Controllable.GroupControlDisposition">GroupControlDisposition</a>)</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from ARDOUR:Route</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">active</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, int, ARDOUR::Route::ProcessorStreams*, bool)">add_processor_by_index</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">int</span>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">add_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::Route::*)()">comment</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, unsigned int, ARDOUR::ChanCount)">customize_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <span class="em">unsigned int</span>, <a class="" href="#ARDOUR:ChanCount">ChanCount</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_inputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:ChanCount">ChanCount</a></td><td class="decl"><span class="functionname"><abbr title="ARDOUR::ChanCount (ARDOUR::Route::*)() const">n_outputs</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:Processor">Processor</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;ARDOUR::Processor&gt; (ARDOUR::Route::*)(unsigned int) const">nth_plugin</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*, bool)">remove_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">remove_sidechain</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;, boost::shared_ptr&lt;ARDOUR::Processor&gt;, ARDOUR::Route::ProcessorStreams*)">replace_processor</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Processor">Processor</a>, <a class="" href="#ARDOUR:Route:ProcessorStreams">ProcessorStreams</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(boost::shared_ptr&lt;ARDOUR::Processor&gt;)">reset_plugin_insert</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Processor">Processor</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(bool, void*)">set_active</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (ARDOUR::Route::*)(std::string, void*)">set_comment</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">void*</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)(bool)">set_strict_io</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (ARDOUR::Route::*)() const">strict_io</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from ARDOUR:SessionObject</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (ARDOUR::SessionObject::*)() const">name</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="ARDOUR:WeakAudioSourceList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:WeakAudioSourceList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::weak_ptr&lt;ARDOUR::AudioSource&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.WeakAudioSourceList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::weak_ptr&lt;ARDOUR::AudioSource&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::weak_ptr&lt;ARDOUR::AudioSource&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::weak_ptr&lt;ARDOUR::AudioSource&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:WeakPortSet" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:WeakPortSet</h3>
<p class="cdecl"><em>C&#8225;</em>: std::set&lt;boost::weak_ptr&lt;ARDOUR::AudioPort&gt; &gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.WeakPortSet</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">ARDOUR::AudioPort</span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::set&lt;boost::weak_ptr&lt;ARDOUR::AudioPort&gt; &gt; &gt;::*)()">clear</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::set&lt;boost::weak_ptr&lt;ARDOUR::AudioPort&gt; &gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::set&lt;boost::weak_ptr&lt;ARDOUR::AudioPort&gt; &gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:WeakRouteList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:WeakRouteList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::weak_ptr&lt;ARDOUR::Route&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.WeakRouteList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::weak_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::weak_ptr&lt;ARDOUR::Route&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::weak_ptr&lt;ARDOUR::Route&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ARDOUR:WeakSourceList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ARDOUR:WeakSourceList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;boost::weak_ptr&lt;ARDOUR::Source&gt; &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">ARDOUR.WeakSourceList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;boost::weak_ptr&lt;ARDOUR::Source&gt; &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;boost::weak_ptr&lt;ARDOUR::Source&gt; &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;boost::weak_ptr&lt;ARDOUR::Source&gt; &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ArdourUI:ArdourMarker" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;ArdourUI:ArdourMarker</h3>
<p class="cdecl"><em>C&#8225;</em>: ArdourMarker</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Location Marker</p><p> Editor ruler representation of a location marker or range on the timeline.</p></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h3 id="ArdourUI:Editor" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ArdourUI:Editor</h3>
<p class="cdecl"><em>C&#8225;</em>: PublicEditor</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> This class contains just the public interface of the Editor class, in order to decouple it from the private implementation, so that callers of PublicEditor need not be recompiled if private methods or member variables change.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(std::string, std::string)">access_action</abbr></span><span class="functionargs"> (<span class="em">std::string</span>, <span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">add_location_from_playhead_cursor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(long)">center_screen</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(boost::shared_ptr&lt;ARDOUR::Region&gt;)">consider_auditioning</abbr></span><span class="functionargs"> (<a class="" href="#ARDOUR:Region">Region</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Possibly start the audition of a region.  If </p><dl><dt class="param-name-index-0">r</dt><dd class="param-descr-index-0"> is 0, or not an AudioRegion any current audition is cancelled.  If we are currently auditioning </dd><dt class="param-name-index-0">r</dt><dd class="param-descr-index-0"> will start. </dd><dt class="param-name-index-0">r</dt><dd class="param-descr-index-0"> Region to consider.</dd><dt class="param-name-index-invalid">r,</dt><dd class="param-descr-index-invalid"> the audition will be cancelled.  Otherwise an audition of </dd></dl></div></td></tr>
 <tr><td class="def"><a class="" href="#Editing.MouseMode">MouseMode</a></td><td class="decl"><span class="functionname"><abbr title="Editing::MouseMode (PublicEditor::*)() const">current_mouse_mode</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  The current mouse mode (gain, object, range, timefx etc.) (defined in editing_syms.h)</p></div></div></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)() const">current_page_samples</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">deselect_all</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(...)</td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(std::vector&lt;std::string &gt;, Editing::ImportDisposition, Editing::ImportMode, long&amp;, boost::shared_ptr&lt;ARDOUR::PluginInfo&gt;)">do_embed</abbr></span><span class="functionargs"> (<a class="" href="#C:StringVector">StringVector</a>, <a class="" href="#Editing.ImportDisposition">ImportDisposition</a>, <a class="" href="#Editing.ImportMode">ImportMode</a>, <span class="em">long&amp;</span>, <a class="" href="#ARDOUR:PluginInfo">PluginInfo</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(...)</td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(std::vector&lt;std::string &gt;, Editing::ImportDisposition, Editing::ImportMode, ARDOUR::SrcQuality, long&amp;, boost::shared_ptr&lt;ARDOUR::PluginInfo&gt;)">do_import</abbr></span><span class="functionargs"> (<a class="" href="#C:StringVector">StringVector</a>, <a class="" href="#Editing.ImportDisposition">ImportDisposition</a>, <a class="" href="#Editing.ImportMode">ImportMode</a>, <a class="" href="#ARDOUR.SrcQuality">SrcQuality</a>, <span class="em">long&amp;</span>, <a class="" href="#ARDOUR:PluginInfo">PluginInfo</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)() const">dragging_playhead</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  true if the playhead is currently being dragged, otherwise false </p></div></div></td></tr>
 <tr><td class="def"><a class="" href="#Editing.MouseMode">MouseMode</a></td><td class="decl"><span class="functionname"><abbr title="Editing::MouseMode (PublicEditor::*)() const">effective_mouse_mode</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">export_audio</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Open main export dialog </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">export_range</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Open export dialog with current range pre-selected </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">export_selection</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Open export dialog with current selection pre-selected </p></div></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<a class="" href="#ARDOUR:Location">Location</a>, ...)</td><td class="decl"><span class="functionname"><abbr title="ARDOUR::Location* (PublicEditor::*)(ArdourMarker*, bool&amp;) const">find_location_from_marker</abbr></span><span class="functionargs"> (<a class="" href="#ArdourUI:ArdourMarker">ArdourMarker</a>, <span class="em">bool&amp;</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ArdourUI:ArdourMarker">ArdourMarker</a></td><td class="decl"><span class="functionname"><abbr title="ArdourMarker* (PublicEditor::*)(PBD::ID const&amp;, bool) const">find_marker_from_location_id</abbr></span><span class="functionargs"> (<a class="" href="#PBD:ID">ID</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)() const">follow_playhead</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><div class="result-discussion"><p class="para-returns"><span class="word-returns">Returns</span>  true if the editor is following the playhead </p></div></div></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)() const">get_current_zoom</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (PublicEditor::*)(long)">get_grid_beat_divisions</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<a class="" href="#Evoral:Beats">Beats</a>, ...)</td><td class="decl"><span class="functionname"><abbr title="Evoral::Beats (PublicEditor::*)(bool&amp;, long)">get_grid_type_as_beats</abbr></span><span class="functionargs"> (<span class="em">bool&amp;</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(<span class="em">long</span>, ...)</td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)(long, long&amp;)">get_nudge_distance</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">long&amp;</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)(long, unsigned int, long)">get_paste_offset</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">unsigned int</span>, <span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em>(...)</td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(double&amp;, double&amp;) const">get_pointer_position</abbr></span><span class="functionargs"> (<span class="em">double&amp;</span>, <span class="em">double&amp;</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)() const">get_smart_mode</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">int</span></td><td class="decl"><span class="functionname"><abbr title="int (PublicEditor::*)() const">get_videotl_bar_height</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (PublicEditor::*)() const">get_y_origin</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Editing.ZoomFocus">ZoomFocus</a></td><td class="decl"><span class="functionname"><abbr title="Editing::ZoomFocus (PublicEditor::*)() const">get_zoom_focus</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(int)">goto_nth_marker</abbr></span><span class="functionargs"> (<span class="em">int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)() const">leftmost_sample</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">maximise_editing_space</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(long)">maybe_locate_with_edit_preroll</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(long, bool)">mouse_add_new_marker</abbr></span><span class="functionargs"> (<span class="em">long</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">new_region_from_selection</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">override_visible_track_count</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (PublicEditor::*)(double) const">pixel_to_sample</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">play_selection</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">play_with_preroll</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(unsigned int)">redo</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Redo some transactions. </p><dl><dt class="param-name-index-0">n</dt><dd class="param-descr-index-0"> Number of transaction to redo.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">remove_last_capture</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">remove_location_at_playhead_cursor</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">remove_tracks</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(long)">reset_x_origin</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(double)">reset_y_origin</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(long)">reset_zoom</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">restore_editing_space</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (PublicEditor::*)(long) const">sample_to_pixel</abbr></span><span class="functionargs"> (<span class="em">long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)(bool)">scroll_down_one_track</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">scroll_tracks_down_line</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">scroll_tracks_up_line</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)(bool)">scroll_up_one_track</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">select_all_tracks</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">separate_region_from_selection</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(bool, bool)">set_follow_playhead</abbr></span><span class="functionargs"> (<span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set whether the editor should follow the playhead. </p><dl><dt class="param-name-index-0">yn</dt><dd class="param-descr-index-0"> true to follow playhead, otherwise false. </dd><dt class="param-name-index-1">catch_up</dt><dd class="param-descr-index-1"> true to reset the editor view to show the playhead (if yn == true), otherwise false.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(Editing::MouseMode, bool)">set_mouse_mode</abbr></span><span class="functionargs"> (<a class="" href="#Editing.MouseMode">MouseMode</a>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the mouse mode (gain, object, range, timefx etc.) </p><dl><dt class="param-name-index-0">m</dt><dd class="param-descr-index-0"> Mouse mode (defined in editing_syms.h) </dd><dt class="param-name-index-1">force</dt><dd class="param-descr-index-1"> Perform the effects of the change even if no change is required (ie even if the current mouse mode is equal to </dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(bool)">set_show_measures</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(Editing::SnapMode)">set_snap_mode</abbr></span><span class="functionargs"> (<a class="" href="#Editing.SnapMode">SnapMode</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the snap mode. </p><dl><dt class="param-name-index-0">m</dt><dd class="param-descr-index-0"> Snap mode (defined in editing_syms.h)</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(double)">set_snap_threshold</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Set the snap threshold. </p><dl><dt class="param-name-index-0">t</dt><dd class="param-descr-index-0"> Snap threshold in `units&#39;.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(bool)">set_stationary_playhead</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(int)">set_video_timeline_height</abbr></span><span class="functionargs"> (<span class="em">int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(Editing::ZoomFocus)">set_zoom_focus</abbr></span><span class="functionargs"> (<a class="" href="#Editing.ZoomFocus">ZoomFocus</a>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)() const">show_measures</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Editing.SnapMode">SnapMode</a></td><td class="decl"><span class="functionname"><abbr title="Editing::SnapMode (PublicEditor::*)() const">snap_mode</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Editing.SnapType">SnapType</a></td><td class="decl"><span class="functionname"><abbr title="Editing::SnapType (PublicEditor::*)() const">snap_type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (PublicEditor::*)() const">stationary_playhead</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">stem_export</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Open stem export dialog </p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(bool)">temporal_zoom_step</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)()">toggle_meter_updating</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(bool)">toggle_ruler_video</abbr></span><span class="functionargs"> (<span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(int)">toggle_xjadeo_proc</abbr></span><span class="functionargs"> (<span class="em">int</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (PublicEditor::*)(unsigned int)">undo</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Undo some transactions. </p><dl><dt class="param-name-index-0">n</dt><dd class="param-descr-index-0"> Number of transactions to undo.</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (PublicEditor::*)() const">visible_canvas_height</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="ArdourUI:RegionSelection" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;ArdourUI:RegionSelection</h3>
<p class="cdecl"><em>C&#8225;</em>: RegionSelection</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Class to represent list of selected regions.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (RegionSelection::*)()">clear_all</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Empty this RegionSelection.</p></div></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (RegionSelection::*)() const">end_frame</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (RegionSelection::*)() const">n_midi_regions</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">long</span></td><td class="decl"><span class="functionname"><abbr title="long (RegionSelection::*)() const">start</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="C:DoubleVector" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;C:DoubleVector</h3>
<p class="cdecl"><em>C&#8225;</em>: std::vector&lt;double &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">C.DoubleVector</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">double</span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double&amp; (std::vector&lt;double &gt;::*)(unsigned long)">at</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::vector&lt;double &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::vector&lt;double &gt;::*)(double const&amp;)">push_back</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::vector&lt;double &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="C:FloatArray" class="cls array"><abbr title="C Array">&ctdot;</abbr>&nbsp;C:FloatArray</h3>
<p class="cdecl"><em>C&#8225;</em>: float*</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaMetaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">array</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">get_table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>void</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">set_table</abbr></span><span class="functionargs"> (<span class="em">LuaTable {float}</span>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="C:IntArray" class="cls array"><abbr title="C Array">&ctdot;</abbr>&nbsp;C:IntArray</h3>
<p class="cdecl"><em>C&#8225;</em>: int*</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaMetaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">array</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">get_table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>void</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*)">set_table</abbr></span><span class="functionargs"> (<span class="em">LuaTable {int}</span>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="C:StringList" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;C:StringList</h3>
<p class="cdecl"><em>C&#8225;</em>: std::list&lt;std::string &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">C.StringList</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">std::string</span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::list&lt;std::string &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;std::string &gt;::*)(std::string const&amp;)">push_back</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;std::string &gt;::*)()">reverse</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::list&lt;std::string &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::list&lt;std::string &gt;::*)()">unique</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="C:StringVector" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;C:StringVector</h3>
<p class="cdecl"><em>C&#8225;</em>: std::vector&lt;std::string &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">C.StringVector</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">std::string</span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string&amp; (std::vector&lt;std::string &gt;::*)(unsigned long)">at</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::vector&lt;std::string &gt;::*)() const">empty</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaIter</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">iter</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (std::vector&lt;std::string &gt;::*)(std::string const&amp;)">push_back</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::vector&lt;std::string &gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Cairo:Context" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Cairo:Context</h3>
<p class="cdecl"><em>C&#8225;</em>: Cairo::Context</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Context is the main class used to draw in cairomm. It contains the current state of the rendering device, including coordinates of yet to be drawn  shapes.</p><p> In the simplest case, create a Context with its target Surface, set its drawing options (line width, color, etc), create shapes with methods like move_to() and line_to(), and then draw the shapes to the Surface using methods such as stroke() or fill().</p><p> Context is a reference-counted object that should be used via Cairo::RefPtr.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double, double)">arc</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a circular arc of the given radius to the current path. The arc is centered at (<em>xc,</em> <em>yc),</em> begins at <em>angle1</em> and proceeds in the direction of increasing angles to end at <em>angle2.</em> If <em>angle2</em> is less than <em>angle1</em> it will be progressively increased by 2*M_PI until it is greater than <em>angle1.</em></p><p> If there is a current point, an initial line segment will be added to the path to connect the current point to the beginning of the arc. If this initial line is undesired, it can be avoided by calling begin_new_sub_path() before calling arc().</p><p> Angles are measured in radians. An angle of 0 is in the direction of the positive X axis (in user-space). An angle of M_PI&#47;2.0 radians (90 degrees) is in the direction of the positive Y axis (in user-space). Angles increase in the direction from the positive X axis toward the positive Y axis. So with the default transformation matrix, angles increase in a clockwise direction.</p><p> ( To convert from degrees to radians, use degrees * (M_PI &#47; 180.0). )</p><p> This function gives the arc in the direction of increasing angles; see arc_negative() to get the arc in the direction of decreasing angles.</p><p> The arc is circular in user-space. To achieve an elliptical arc, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an ellipse in the box given by x, y, width, height:</p><pre> context-&gt;save();
 context-&gt;translate(x, y);
 context-&gt;scale(width &#47; 2.0, height &#47; 2.0);
 context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);
 context-&gt;restore();</pre><dl><dt class="param-name-index-0">xc</dt><dd class="param-descr-index-0">	X position of the center of the arc </dd><dt class="param-name-index-1">yc</dt><dd class="param-descr-index-1">	Y position of the center of the arc </dd><dt class="param-name-index-2">radius</dt><dd class="param-descr-index-2">	the radius of the arc </dd><dt class="param-name-index-3">angle1</dt><dd class="param-descr-index-3">	the start angle, in radians </dd><dt class="param-name-index-4">angle2</dt><dd class="param-descr-index-4">	the end angle, in radians</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double, double)">arc_negative</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a circular arc of the given <em>radius</em> to the current path. The arc is centered at (<em>xc,</em> <em>yc),</em> begins at <em>angle1</em> and proceeds in the direction of decreasing angles to end at <em>angle2.</em> If <em>angle2</em> is greater than <em>angle1</em> it will be progressively decreased by 2*M_PI until it is greater than <em>angle1.</em></p><p> See arc() for more details. This function differs only in the direction of the arc between the two angles.</p><dl><dt class="param-name-index-0">xc</dt><dd class="param-descr-index-0">	X position of the center of the arc </dd><dt class="param-name-index-1">yc</dt><dd class="param-descr-index-1">	Y position of the center of the arc </dd><dt class="param-name-index-2">radius</dt><dd class="param-descr-index-2">	the radius of the arc </dd><dt class="param-name-index-3">angle1</dt><dd class="param-descr-index-3">	the start angle, in radians </dd><dt class="param-name-index-4">angle2</dt><dd class="param-descr-index-4">	the end angle, in radians</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">begin_new_path</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Clears the current path. After this call there will be no current point.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">begin_new_sub_path</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Begin a new subpath. Note that the existing path is not affected. After this call there will be no current point.</p><p> In many cases, this call is not needed since new subpaths are frequently started with move_to().</p><p> A call to begin_new_sub_path() is particularly useful when beginning a new subpath with one of the arc() calls. This makes things easier as it is no longer necessary to manually compute the arc&#39;s initial coordinates for a call to move_to().</p><p> 1.2</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">clip</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Establishes a new clip region by intersecting the current clip region with the current Path as it would be filled by fill() and according to the current fill rule.</p><p> After clip(), the current path will be cleared from the cairo Context.</p><p> The current clip region affects all drawing operations by effectively masking out any changes to the surface that are outside the current clip region.</p><p> Calling clip() can only make the clip region smaller, never larger.  But the current clip is part of the graphics state, so a temporary restriction of the clip region can be achieved by calling clip() within a save()&#47;restore() pair. The only other means of increasing the size of the clip region is reset_clip().</p><p> set_fill_rule()</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">clip_preserve</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Establishes a new clip region by intersecting the current clip region with the current path as it would be filled by fill() and according to the current fill rule.</p><p> Unlike clip(), clip_preserve preserves the path within the cairo Context.</p><p> clip() </p><p> set_fill_rule()</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">close_path</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a line segment to the path from the current point to the beginning of the current subpath, (the most recent point passed to move_to()), and closes this subpath. After this call the current point will be at the  joined endpoint of the sub-path.</p><p> The behavior of close_path() is distinct from simply calling line_to() with the equivalent coordinate in the case of stroking.  When a closed subpath is stroked, there are no caps on the ends of the subpath. Instead, there is a line join connecting the final and initial segments of the subpath.</p><p> If there is no current point before the call to close_path(), this function will have no effect.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double, double, double)">curve_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a cubic Bezier spline to the path from the current point to position (x3, y3) in user-space coordinates, using (x1, y1) and (x2, y2) as the control points. After this call the current point will be (x3, y3).</p><p> If there is no current point before the call to curve_to() this function will behave as if preceded by a call to move_to(x1, y1).</p><dl><dt class="param-name-index-0">x1</dt><dd class="param-descr-index-0">	the X coordinate of the first control point </dd><dt class="param-name-index-1">y1</dt><dd class="param-descr-index-1">	the Y coordinate of the first control point </dd><dt class="param-name-index-2">x2</dt><dd class="param-descr-index-2">	the X coordinate of the second control point </dd><dt class="param-name-index-3">y2</dt><dd class="param-descr-index-3">	the Y coordinate of the second control point </dd><dt class="param-name-index-4">x3</dt><dd class="param-descr-index-4">	the X coordinate of the end of the curve </dd><dt class="param-name-index-5">y3</dt><dd class="param-descr-index-5">	the Y coordinate of the end of the curve</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">fill</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that fills the current path according to the current fill rule, (each sub-path is implicitly closed before being filled). After fill(), the current path will be cleared from the cairo context.</p><p> set_fill_rule() </p><p> fill_preserve()</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">fill_preserve</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that fills the current path according to the current fill rule, (each sub-path is implicitly closed before being filled). Unlike fill(), fill_preserve() preserves the path within the cairo Context.</p><p> set_fill_rule() </p><p> fill().</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">line_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a line to the path from the current point to position (x, y) in user-space coordinates. After this call the current point will be (x, y).</p><p> If there is no current point before the call to line_to() this function will behave as move_to(x, y).</p><dl><dt class="param-name-index-0">x</dt><dd class="param-descr-index-0">	the X coordinate of the end of the new line </dd><dt class="param-name-index-1">y</dt><dd class="param-descr-index-1">	the Y coordinate of the end of the new line</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">move_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> If the current subpath is not empty, begin a new subpath. After this call the current point will be (x, y).</p><dl><dt class="param-name-index-0">x</dt><dd class="param-descr-index-0">	the X coordinate of the new position </dd><dt class="param-name-index-1">y</dt><dd class="param-descr-index-1">	the Y coordinate of the new position</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">paint</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that paints the current source everywhere within the current clip region.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double)">paint_with_alpha</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that paints the current source everywhere within the current clip region using a mask of constant alpha value alpha. The effect is similar to paint(), but the drawing is faded out using the alpha value.</p><dl><dt class="param-name-index-0">alpha</dt><dd class="param-descr-index-0">	an alpha value, between 0 (transparent) and 1 (opaque)</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double)">rectangle</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Adds a closed-subpath rectangle of the given size to the current path at position (x, y) in user-space coordinates.</p><p> This function is logically equivalent to:</p><pre> context-&gt;move_to(x, y);
 context-&gt;rel_line_to(width, 0);
 context-&gt;rel_line_to(0, height);
 context-&gt;rel_line_to(-width, 0);
 context-&gt;close_path();</pre><dl><dt class="param-name-index-0">x</dt><dd class="param-descr-index-0">	the X coordinate of the top left corner of the rectangle </dd><dt class="param-name-index-1">y</dt><dd class="param-descr-index-1">	the Y coordinate to the top left corner of the rectangle </dd><dt class="param-name-index-2">width</dt><dd class="param-descr-index-2">	the width of the rectangle </dd><dt class="param-name-index-3">height</dt><dd class="param-descr-index-3">	the height of the rectangle</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double, double, double)">rel_curve_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Relative-coordinate version of curve_to(). All offsets are relative to the current point. Adds a cubic Bezier spline to the path from the current point to a point offset from the current point by (dx3, dy3), using points offset by (dx1, dy1) and (dx2, dy2) as the control points.  After this call the current point will be offset by (dx3, dy3).</p><p> Given a current point of (x, y), </p><pre> rel_curve_to(dx1, dy1, dx2, dy2, dx3, dy3)</pre><p> is logically equivalent to </p><pre> curve_to(x + dx1, y + dy1, x + dx2, y + dy2, x + dx3, y + dy3).</pre><p> It is an error to call this function with no current point. Doing so will cause this to shutdown with a status of CAIRO_STATUS_NO_CURRENT_POINT. Cairomm will then throw an exception.</p><dl><dt class="param-name-index-0">dx1</dt><dd class="param-descr-index-0">	the X offset to the first control point </dd><dt class="param-name-index-1">dy1</dt><dd class="param-descr-index-1">	the Y offset to the first control point </dd><dt class="param-name-index-2">dx2</dt><dd class="param-descr-index-2">	the X offset to the second control point </dd><dt class="param-name-index-3">dy2</dt><dd class="param-descr-index-3">	the Y offset to the second control point </dd><dt class="param-name-index-4">dx3</dt><dd class="param-descr-index-4">	the X offset to the end of the curve </dd><dt class="param-name-index-5">dy3</dt><dd class="param-descr-index-5">	the Y offset to the end of the curve</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">rel_line_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Relative-coordinate version of line_to(). Adds a line to the path from the current point to a point that is offset from the current point by (dx, dy) in user space. After this call the current point will be offset by (dx, dy).</p><p> Given a current point of (x, y), </p><pre> rel_line_to(dx, dy)</pre><p> is logically equivalent to </p><pre> line_to(x + dx, y + dy).</pre><p> It is an error to call this function with no current point. Doing so will cause this to shutdown with a status of CAIRO_STATUS_NO_CURRENT_POINT. Cairomm will then throw an exception.</p><dl><dt class="param-name-index-0">dx</dt><dd class="param-descr-index-0">	the X offset to the end of the new line </dd><dt class="param-name-index-1">dy</dt><dd class="param-descr-index-1">	the Y offset to the end of the new line</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">rel_move_to</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> If the current subpath is not empty, begin a new subpath. After this call the current point will offset by (x, y).</p><p> Given a current point of (x, y), </p><pre> rel_move_to(dx, dy)</pre><p> is logically equivalent to </p><pre> move_to(x + dx, y + dy)</pre><p> It is an error to call this function with no current point. Doing so will cause this to shutdown with a status of CAIRO_STATUS_NO_CURRENT_POINT. Cairomm will then throw an exception.</p><dl><dt class="param-name-index-0">dx</dt><dd class="param-descr-index-0">	the X offset </dd><dt class="param-name-index-1">dy</dt><dd class="param-descr-index-1">	the Y offset</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">reset_clip</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Reset the current clip region to its original, unrestricted state. That is, set the clip region to an infinitely large shape containing the target surface. Equivalently, if infinity is too hard to grasp, one can imagine the clip region being reset to the exact bounds of the target surface.</p><p> Note that code meant to be reusable should not call reset_clip() as it will cause results unexpected by higher-level code which calls clip(). Consider using save() and restore() around clip() as a more robust means of temporarily restricting the clip region.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">restore</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Restores cr to the state saved by a preceding call to save() and removes that state from the stack of saved states.</p><p> save()</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double)">rotate</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Modifies the current transformation matrix (CTM) by rotating the user-space axes by angle radians. The rotation of the axes takes places after any existing transformation of user space. The rotation direction for positive angles is from the positive X axis toward the positive Y axis.</p><dl><dt class="param-name-index-invalid">angle</dt><dd class="param-descr-index-invalid">	angle (in radians) by which the user-space axes will be rotated</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">save</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Makes a copy of the current state of the Context and saves it on an internal stack of saved states. When restore() is called, it will be restored to the saved state. Multiple calls to save() and restore() can be nested; each call to restore() restores the state from the matching paired save().</p><p> It isn&#39;t necessary to clear all saved states before a cairo_t is freed. Any saved states will be freed when the Context is destroyed.</p><p> restore()</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">scale</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Modifies the current transformation matrix (CTM) by scaling the X and Y user-space axes by sx and sy respectively. The scaling of the axes takes place after any existing transformation of user space.</p><dl><dt class="param-name-index-0">sx</dt><dd class="param-descr-index-0">	scale factor for the X dimension </dd><dt class="param-name-index-1">sy</dt><dd class="param-descr-index-1">	scale factor for the Y dimension</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(std::vector&lt;double &gt; const&amp;, double)">set_dash</abbr></span><span class="functionargs"> (<a class="" href="#C:DoubleVector">DoubleVector</a>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double)">set_font_size</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the current font matrix to a scale by a factor of <em>size,</em> replacing any font matrix previously set with set_font_size() or set_font_matrix(). This results in a font size of <em>size</em> user space units. (More precisely, this matrix will result in the font&#39;s em-square being a  by <em>size</em> square in user space.)</p><p> If text is drawn without a call to set_font_size(), (nor set_font_matrix() nor set_scaled_font()), the default font size is 10.0.</p><dl><dt class="param-name-index-0">size</dt><dd class="param-descr-index-0"> the new font size, in user space units)</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(Cairo::LineCap)">set_line_cap</abbr></span><span class="functionargs"> (<a class="" href="#Cairo.LineCap">LineCap</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the current line cap style within the cairo Context. See LineCap for details about how the available line cap styles are drawn.</p><p> As with the other stroke parameters, the current line cap style is examined by stroke(), stroke_extents(), and stroke_to_path(), but does not have any effect during path construction.</p><p> The default line cap style is Cairo::LINE_CAP_BUTT.</p><dl><dt class="param-name-index-0">line_cap</dt><dd class="param-descr-index-0">	a line cap style, as a LineCap</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(Cairo::LineJoin)">set_line_join</abbr></span><span class="functionargs"> (<a class="" href="#Cairo.LineJoin">LineJoin</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the current line join style within the cairo Context. See LineJoin for details about how the available line join styles are drawn.</p><p> As with the other stroke parameters, the current line join style is examined by stroke(), stroke_extents(), and stroke_to_path(), but does not have any effect during path construction.</p><p> The default line join style is Cairo::LINE_JOIN_MITER.</p><dl><dt class="param-name-index-0">line_join</dt><dd class="param-descr-index-0">	a line joint style, as a LineJoin</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double)">set_line_width</abbr></span><span class="functionargs"> (<span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the current line width within the cairo Context. The line width specifies the diameter of a pen that is circular in user-space, (though  device-space pen may be an ellipse in general due to scaling&#47;shear&#47;rotation  of the CTM).</p><p> Note: When the description above refers to user space and CTM it refers to the user space and CTM in effect at the time of the stroking operation, not the user space and CTM in effect at the time of the call to set_line_width(). The simplest usage makes both of these spaces identical. That is, if there is no change to the CTM between a call to set_line_width() and the stroking operation, then one can just pass user-space values to set_line_width() and ignore this note.</p><p> As with the other stroke parameters, the current line cap style is examined by stroke(), stroke_extents(), and stroke_to_path(), but does not have any effect during path construction.</p><p> The default line width value is 2.0.</p><dl><dt class="param-name-index-0">width</dt><dd class="param-descr-index-0">	a line width, as a user-space value</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(Cairo::Operator)">set_operator</abbr></span><span class="functionargs"> (<a class="" href="#Cairo.Operator">Operator</a>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the compositing operator to be used for all drawing operations. See Operator for details on the semantics of each available compositing operator.</p><dl><dt class="param-name-index-0">op</dt><dd class="param-descr-index-0">	a compositing operator, specified as a Operator</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double)">set_source_rgb</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the source pattern within the Context to an opaque color. This opaque color will then be used for any subsequent drawing operation until a new source pattern is set.</p><p> The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p><p> set_source_rgba() </p><p> set_source()</p><dl><dt class="param-name-index-0">red</dt><dd class="param-descr-index-0">	red component of color </dd><dt class="param-name-index-1">green</dt><dd class="param-descr-index-1">	green component of color </dd><dt class="param-name-index-2">blue</dt><dd class="param-descr-index-2">	blue component of color</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double, double, double)">set_source_rgba</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Sets the source pattern within the Context to a translucent color. This color will then be used for any subsequent drawing operation until a new source pattern is set.</p><p> The color and alpha components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p><p> set_source_rgb() </p><p> set_source()</p><dl><dt class="param-name-index-0">red</dt><dd class="param-descr-index-0">	red component of color </dd><dt class="param-name-index-1">green</dt><dd class="param-descr-index-1">	green component of color </dd><dt class="param-name-index-2">blue</dt><dd class="param-descr-index-2">	blue component of color </dd><dt class="param-name-index-3">alpha</dt><dd class="param-descr-index-3">	alpha component of color</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(std::string const&amp;)">show_text</abbr></span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that generates the shape from a string of UTF-8 characters, rendered according to the current font_face, font_size (font_matrix), and font_options.</p><p> This function first computes a set of glyphs for the string of text. The first glyph is placed so that its origin is at the current point. The origin of each subsequent glyph is offset from that of the previous glyph by the advance values of the previous glyph.</p><p> After this call the current point is moved to the origin of where the next glyph would be placed in this same progression. That is, the current point will be at the origin of the final glyph offset by its advance values. This allows for easy display of a single logical string with multiple calls to show_text().</p><p> Note: The show_text() function call is part of what the cairo designers call the &quot;toy&quot; text API. It is convenient for short demos and simple programs, but it is not expected to be adequate for serious text-using applications. See show_glyphs() for the &quot;real&quot; text display API in cairo.</p><dl><dt class="param-name-index-0">utf8</dt><dd class="param-descr-index-0"> a string containing text encoded in UTF-8</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">stroke</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that strokes the current Path according to the current line width, line join, line cap, and dash settings. After stroke(), the current Path will be cleared from the cairo Context.</p><p> set_line_width() </p><p> set_line_join() </p><p> set_line_cap() </p><p> set_dash() </p><p> stroke_preserve().</p><p> Note: Degenerate segments and sub-paths are treated specially and provide a useful result. These can result in two different situations:</p><p> 1. Zero-length &quot;on&quot; segments set in set_dash(). If the cap style is Cairo::LINE_CAP_ROUND or Cairo::LINE_CAP_SQUARE then these segments will be drawn as circular dots or squares respectively. In the case of Cairo::LINE_CAP_SQUARE, the orientation of the squares is determined by the direction of the underlying path.</p><p> 2. A sub-path created by move_to() followed by either a close_path() or one or more calls to line_to() to the same coordinate as the move_to(). If the cap style is Cairo::LINE_CAP_ROUND then these sub-paths will be drawn as circular dots. Note that in the case of Cairo::LINE_CAP_SQUARE a degenerate sub-path will not be drawn at all, (since the correct orientation is indeterminate).</p><p> In no case will a cap style of Cairo::LINE_CAP_BUTT cause anything to be drawn in the case of either degenerate segments or sub-paths.</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">stroke_preserve</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> A drawing operator that strokes the current Path according to the current line width, line join, line cap, and dash settings. Unlike stroke(), stroke_preserve() preserves the Path within the cairo Context.</p><p> set_line_width() </p><p> set_line_join() </p><p> set_line_cap() </p><p> set_dash() </p><p> stroke_preserve().</p></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)(double, double)">translate</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>)</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> Modifies the current transformation matrix (CTM) by translating the user-space origin by (tx, ty). This offset is interpreted as a user-space coordinate according to the CTM in place before the new call to translate. In other words, the translation of the user-space origin takes place after any existing transformation.</p><dl><dt class="param-name-index-0">tx</dt><dd class="param-descr-index-0">	amount to translate in the X direction </dd><dt class="param-name-index-1">ty</dt><dd class="param-descr-index-1">	amount to translate in the Y direction</dd></dl></div></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Cairo::Context::*)()">unset_dash</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
<tr><td></td><td class="doc" colspan="2"><div class="dox"><p class="para-brief"> This function disables a dash pattern that was set with set_dash()</p></div></td></tr>
 </table>
<h3 id="Evoral:Beats" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Evoral:Beats</h3>
<p class="cdecl"><em>C&#8225;</em>: Evoral::Beats</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Musical time in beats. </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (Evoral::Beats::*)() const">to_double</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:Control" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;Evoral:Control</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; Evoral::Control &gt;, boost::weak_ptr&lt; Evoral::Control &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#Evoral:ControlList">ControlList</a></td><td class="decl"><span class="functionname"><abbr title="boost::shared_ptr&lt;Evoral::ControlList&gt; (Evoral::Control::*)()">list</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:ControlList" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;Evoral:ControlList</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; Evoral::ControlList &gt;, boost::weak_ptr&lt; Evoral::ControlList &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Evoral::ControlList::*)(double, double, bool, bool)">add</abbr></span><span class="functionargs"> (<span class="em">double</span>, <span class="em">double</span>, <span class="em">bool</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:ControlSet" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;Evoral:ControlSet</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; Evoral::ControlSet &gt;, boost::weak_ptr&lt; Evoral::ControlSet &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:Event" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Evoral:Event</h3>
<p class="cdecl"><em>C&#8225;</em>: Evoral::Event&lt;long&gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned char*</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char* (Evoral::Event&lt;long&gt;::*)()">buffer</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Evoral::Event&lt;long&gt;::*)()">clear</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Evoral::Event&lt;long&gt;::*)(unsigned int, unsigned char*, bool)">set_buffer</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">unsigned char*</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (Evoral::Event&lt;long&gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:MidiEvent" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Evoral:MidiEvent</h3>
<p class="cdecl"><em>C&#8225;</em>: Evoral::MIDIEvent&lt;long&gt;</p>
 <p class="classinfo">is-a: <a class="" href="#Evoral:Event">Evoral:Event</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned char</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char (Evoral::MIDIEvent&lt;long&gt;::*)() const">channel</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned char</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char (Evoral::MIDIEvent&lt;long&gt;::*)() const">set_channel</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned char</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char (Evoral::MIDIEvent&lt;long&gt;::*)() const">set_type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned char</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char (Evoral::MIDIEvent&lt;long&gt;::*)() const">type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from Evoral:Event</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned char*</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char* (Evoral::Event&lt;long&gt;::*)()">buffer</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Evoral::Event&lt;long&gt;::*)()">clear</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">void</span></td><td class="decl"><span class="functionname"><abbr title="void (Evoral::Event&lt;long&gt;::*)(unsigned int, unsigned char*, bool)">set_buffer</abbr></span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">unsigned char*</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (Evoral::Event&lt;long&gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="Evoral:Parameter" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Evoral:Parameter</h3>
<p class="cdecl"><em>C&#8225;</em>: Evoral::Parameter</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> ID of a [play|record|automate]able parameter.</p><p> A parameter is defined by (type, id, channel).  Type is an integer which can be used in any way by the application (e.g. cast to a custom enum, map to&#47;from a URI, etc).  ID is type specific (e.g. MIDI controller #).</p><p> This class defines a &lt; operator which is a strict weak ordering, so Parameter may be stored in a std::set, used as a std::map key, etc.</p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">Evoral.Parameter</span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">unsigned char</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">unsigned char</span></td><td class="decl"><span class="functionname"><abbr title="unsigned char (Evoral::Parameter::*)() const">channel</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (Evoral::Parameter::*)() const">id</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned int</span></td><td class="decl"><span class="functionname"><abbr title="unsigned int (Evoral::Parameter::*)() const">type</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Evoral:ParameterDescriptor" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Evoral:ParameterDescriptor</h3>
<p class="cdecl"><em>C&#8225;</em>: Evoral::ParameterDescriptor</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Description of the value range of a parameter or control. </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">Evoral.ParameterDescriptor</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Data Members</th></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">lower</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">normal</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname">toggled</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">float</span></td><td class="decl"><span class="functionname">upper</span></td><td class="fill"></td></tr>
 </table>
<h3 id="LuaSignal:Set" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;LuaSignal:Set</h3>
<p class="cdecl"><em>C&#8225;</em>: std::bitset&lt;47ul&gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">LuaSignal.Set</span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">add</abbr></span><span class="functionargs"> (<em>LuaTable</em> {<span class="em">47ul</span>})</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::bitset&lt;47ul&gt;::*)() const">any</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::bitset&lt;47ul&gt;::*)() const">count</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::bitset&lt;47ul&gt;::*)() const">none</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#LuaSignal:Set">Set</a></td><td class="decl"><span class="functionname"><abbr title="std::bitset&lt;47ul&gt;&amp; (std::bitset&lt;47ul&gt;::*)()">reset</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#LuaSignal:Set">Set</a></td><td class="decl"><span class="functionname"><abbr title="std::bitset&lt;47ul&gt;&amp; (std::bitset&lt;47ul&gt;::*)(unsigned long, bool)">set</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>, <span class="em">bool</span>)</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">unsigned long</span></td><td class="decl"><span class="functionname"><abbr title="unsigned long (std::bitset&lt;47ul&gt;::*)() const">size</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><em>LuaTable</em></td><td class="decl"><span class="functionname"><abbr title="int (*)(lua_State*) const">table</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="bool (std::bitset&lt;47ul&gt;::*)(unsigned long) const">test</abbr></span><span class="functionargs"> (<span class="em">unsigned long</span>)</span></td><td class="fill"></td></tr>
 </table>
<h3 id="PBD:Controllable" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;PBD:Controllable</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; PBD::Controllable &gt;, boost::weak_ptr&lt; PBD::Controllable &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:StatefulDestructiblePtr">PBD:StatefulDestructiblePtr</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">double</span></td><td class="decl"><span class="functionname"><abbr title="double (PBD::Controllable::*)() const">get_value</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="PBD:ID" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;PBD:ID</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::ID</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">PBD.ID</span><span class="functionargs"> (<span class="em">std::string</span>)</span></td><td class="fill"></td></tr>
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">std::string</span></td><td class="decl"><span class="functionname"><abbr title="std::string (PBD::ID::*)() const">to_s</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="PBD:Stateful" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;PBD:Stateful</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::Stateful</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Base class for objects with saveable and undoable state </p></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="PBD:StatefulDestructible" class="cls opaque"><abbr title="Opaque Object">&empty;</abbr>&nbsp;PBD:StatefulDestructible</h3>
<p class="cdecl"><em>C&#8225;</em>: PBD::StatefulDestructible</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:Stateful">PBD:Stateful</a></p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Base class for objects with saveable and undoable state with destruction notification </p></div>
<p class="classinfo">This class object is only used indirectly as return-value and function-parameter. It provides no methods by itself.</p>
<h4 class="cls">Inherited from PBD:Stateful</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="PBD:StatefulDestructiblePtr" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;PBD:StatefulDestructiblePtr</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; PBD::StatefulDestructible &gt;, boost::weak_ptr&lt; PBD::StatefulDestructible &gt;</p>
 <p class="classinfo">is-a: <a class="" href="#PBD:StatefulPtr">PBD:StatefulPtr</a></p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h4 class="cls">Inherited from PBD:StatefulPtr</h4>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
</table>
<h3 id="PBD:StatefulPtr" class="cls pointerclass"><abbr title="Pointer Class">&Rarr;</abbr>&nbsp;PBD:StatefulPtr</h3>
<p class="cdecl"><em>C&#8225;</em>: boost::shared_ptr&lt; PBD::Stateful &gt;, boost::weak_ptr&lt; PBD::Stateful &gt;</p>
<div class="clear"></div>
<table class="classmembers">
 <tr><th colspan="3">Methods</th></tr>
 <tr><td class="def"><span class="em">bool</span></td><td class="decl"><span class="functionname"><abbr title="void (*)()">isnil</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 <tr><td class="def"><a class="" href="#ARDOUR:OwnedPropertyList">OwnedPropertyList</a></td><td class="decl"><span class="functionname"><abbr title="PBD::OwnedPropertyList const&amp; (PBD::Stateful::*)() const">properties</abbr></span><span class="functionargs"> ()</span></td><td class="fill"></td></tr>
 </table>
<h3 id="Timecode:BBT_TIME" class="cls class"><abbr title="Class">&comp;</abbr>&nbsp;Timecode:BBT_TIME</h3>
<p class="cdecl"><em>C&#8225;</em>: Timecode::BBT_Time</p>
<div class="clear"></div>
<div class="classdox"><p class="para-brief"> Bar, Beat, Tick Time (i.e. Tempo-Based Time) </p></div>
<table class="classmembers">
 <tr><th colspan="3">Constructor</th></tr>
 <tr><td class="def">&Copf;</td><td class="decl"><span class="functionname">Timecode.BBT_TIME</span><span class="functionargs"> (<span class="em">unsigned int</span>, <span class="em">unsigned int</span>, <span class="em">unsigned int</span>)</span></td><td class="fill"></td></tr>
 </table>
<h2 id="h_enum">Enum/Constants</h2>
<h3 id="PBD.Controllable.GroupControlDisposition" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;PBD.Controllable.GroupControlDisposition</h3>
<ul class="enum">
<li class="const">PBD.GroupControlDisposition.InverseGroup</li>
<li class="const">PBD.GroupControlDisposition.NoGroup</li>
<li class="const">PBD.GroupControlDisposition.UseGroup</li>
</ul>
<h3 id="ARDOUR.ChanMapping" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.ChanMapping</h3>
<ul class="enum">
<li class="const">ARDOUR.ChanMapping.Invalid</li>
</ul>
<h3 id="PBD.PropertyDescriptor&lt;long&gt;*" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;PBD.PropertyDescriptor&lt;long&gt;*</h3>
<ul class="enum">
<li class="const">ARDOUR.Properties.Start</li>
<li class="const">ARDOUR.Properties.Length</li>
<li class="const">ARDOUR.Properties.Position</li>
</ul>
<h3 id="ARDOUR.PluginType" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.PluginType</h3>
<ul class="enum">
<li class="const">ARDOUR.PluginType.AudioUnit</li>
<li class="const">ARDOUR.PluginType.LADSPA</li>
<li class="const">ARDOUR.PluginType.LV2</li>
<li class="const">ARDOUR.PluginType.Windows_VST</li>
<li class="const">ARDOUR.PluginType.LXVST</li>
<li class="const">ARDOUR.PluginType.Lua</li>
</ul>
<h3 id="ARDOUR.AutoStyle" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.AutoStyle</h3>
<ul class="enum">
<li class="const">ARDOUR.AutoStyle.Absolute</li>
<li class="const">ARDOUR.AutoStyle.Trim</li>
</ul>
<h3 id="ARDOUR.AutoState" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.AutoState</h3>
<ul class="enum">
<li class="const">ARDOUR.AutoState.Off</li>
<li class="const">ARDOUR.AutoState.Write</li>
<li class="const">ARDOUR.AutoState.Touch</li>
<li class="const">ARDOUR.AutoState.Play</li>
</ul>
<h3 id="ARDOUR.AutomationType" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.AutomationType</h3>
<ul class="enum">
<li class="const">ARDOUR.AutomationType.PluginAutomation</li>
</ul>
<h3 id="ARDOUR.SrcQuality" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.SrcQuality</h3>
<ul class="enum">
<li class="const">ARDOUR.SrcQuality.SrcBest</li>
</ul>
<h3 id="ARDOUR.PlaylistDisposition" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.PlaylistDisposition</h3>
<ul class="enum">
<li class="const">ARDOUR.PlaylistDisposition.CopyPlaylist</li>
<li class="const">ARDOUR.PlaylistDisposition.NewPlaylist</li>
<li class="const">ARDOUR.PlaylistDisposition.SharePlaylist</li>
</ul>
<h3 id="ARDOUR.Session.RecordState" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.Session.RecordState</h3>
<ul class="enum">
<li class="const">ARDOUR.Session.RecordState.Disabled</li>
<li class="const">ARDOUR.Session.RecordState.Enabled</li>
<li class="const">ARDOUR.Session.RecordState.Recording</li>
</ul>
<h3 id="Cairo.LineCap" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Cairo.LineCap</h3>
<ul class="enum">
<li class="const">Cairo.LineCap.Butt</li>
<li class="const">Cairo.LineCap.Round</li>
<li class="const">Cairo.LineCap.Square</li>
</ul>
<h3 id="Cairo.LineJoin" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Cairo.LineJoin</h3>
<ul class="enum">
<li class="const">Cairo.LineJoin.Miter</li>
<li class="const">Cairo.LineJoin.Round</li>
<li class="const">Cairo.LineJoin.Bevel</li>
</ul>
<h3 id="Cairo.Operator" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Cairo.Operator</h3>
<ul class="enum">
<li class="const">Cairo.Operator.Clear</li>
<li class="const">Cairo.Operator.Source</li>
<li class="const">Cairo.Operator.Over</li>
<li class="const">Cairo.Operator.Add</li>
</ul>
<h3 id="LuaSignal.LuaSignal" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;LuaSignal.LuaSignal</h3>
<ul class="enum">
<li class="const">LuaSignal.ConfigChanged</li>
<li class="const">LuaSignal.EngineRunning</li>
<li class="const">LuaSignal.EngineStopped</li>
<li class="const">LuaSignal.EngineHalted</li>
<li class="const">LuaSignal.EngineDeviceListChanged</li>
<li class="const">LuaSignal.BufferSizeChanged</li>
<li class="const">LuaSignal.SampleRateChanged</li>
<li class="const">LuaSignal.FeedbackDetected</li>
<li class="const">LuaSignal.SuccessfulGraphSort</li>
<li class="const">LuaSignal.StartTimeChanged</li>
<li class="const">LuaSignal.EndTimeChanged</li>
<li class="const">LuaSignal.Exported</li>
<li class="const">LuaSignal.SessionConfigChanged</li>
<li class="const">LuaSignal.TransportStateChange</li>
<li class="const">LuaSignal.DirtyChanged</li>
<li class="const">LuaSignal.StateSaved</li>
<li class="const">LuaSignal.Xrun</li>
<li class="const">LuaSignal.TransportLooped</li>
<li class="const">LuaSignal.SoloActive</li>
<li class="const">LuaSignal.SoloChanged</li>
<li class="const">LuaSignal.IsolatedChanged</li>
<li class="const">LuaSignal.MonitorChanged</li>
<li class="const">LuaSignal.RecordStateChanged</li>
<li class="const">LuaSignal.RecordArmStateChanged</li>
<li class="const">LuaSignal.AudioLoopLocationChanged</li>
<li class="const">LuaSignal.AudioPunchLocationChanged</li>
<li class="const">LuaSignal.LocationsModified</li>
<li class="const">LuaSignal.AuditionActive</li>
<li class="const">LuaSignal.BundleAddedOrRemoved</li>
<li class="const">LuaSignal.PositionChanged</li>
<li class="const">LuaSignal.Located</li>
<li class="const">LuaSignal.RoutesReconnected</li>
<li class="const">LuaSignal.RouteAdded</li>
<li class="const">LuaSignal.RouteAddedOrRemoved</li>
<li class="const">LuaSignal.RouteGroupPropertyChanged</li>
<li class="const">LuaSignal.RouteAddedToRouteGroup</li>
<li class="const">LuaSignal.RouteRemovedFromRouteGroup</li>
<li class="const">LuaSignal.StepEditStatusChange</li>
<li class="const">LuaSignal.RouteGroupAdded</li>
<li class="const">LuaSignal.RouteGroupRemoved</li>
<li class="const">LuaSignal.RouteGroupsReordered</li>
<li class="const">LuaSignal.SyncOrderKeys</li>
<li class="const">LuaSignal.PluginListChanged</li>
<li class="const">LuaSignal.PluginStatusesChanged</li>
<li class="const">LuaSignal.DiskOverrun</li>
<li class="const">LuaSignal.DiskUnderrun</li>
<li class="const">LuaSignal.RegionPropertyChanged</li>
</ul>
<h3 id="Editing.SnapType" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.SnapType</h3>
<ul class="enum">
<li class="const">Editing.SnapToCDFrame</li>
<li class="const">Editing.SnapToTimecodeFrame</li>
<li class="const">Editing.SnapToTimecodeSeconds</li>
<li class="const">Editing.SnapToTimecodeMinutes</li>
<li class="const">Editing.SnapToSeconds</li>
<li class="const">Editing.SnapToMinutes</li>
<li class="const">Editing.SnapToBeatDiv128</li>
<li class="const">Editing.SnapToBeatDiv64</li>
<li class="const">Editing.SnapToBeatDiv32</li>
<li class="const">Editing.SnapToBeatDiv28</li>
<li class="const">Editing.SnapToBeatDiv24</li>
<li class="const">Editing.SnapToBeatDiv20</li>
<li class="const">Editing.SnapToBeatDiv16</li>
<li class="const">Editing.SnapToBeatDiv14</li>
<li class="const">Editing.SnapToBeatDiv12</li>
<li class="const">Editing.SnapToBeatDiv10</li>
<li class="const">Editing.SnapToBeatDiv8</li>
<li class="const">Editing.SnapToBeatDiv7</li>
<li class="const">Editing.SnapToBeatDiv6</li>
<li class="const">Editing.SnapToBeatDiv5</li>
<li class="const">Editing.SnapToBeatDiv4</li>
<li class="const">Editing.SnapToBeatDiv3</li>
<li class="const">Editing.SnapToBeatDiv2</li>
<li class="const">Editing.SnapToBeat</li>
<li class="const">Editing.SnapToBar</li>
<li class="const">Editing.SnapToMark</li>
<li class="const">Editing.SnapToRegionStart</li>
<li class="const">Editing.SnapToRegionEnd</li>
<li class="const">Editing.SnapToRegionSync</li>
<li class="const">Editing.SnapToRegionBoundary</li>
</ul>
<h3 id="Editing.SnapMode" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.SnapMode</h3>
<ul class="enum">
<li class="const">Editing.SnapOff</li>
<li class="const">Editing.SnapNormal</li>
<li class="const">Editing.SnapMagnetic</li>
</ul>
<h3 id="Editing.MouseMode" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.MouseMode</h3>
<ul class="enum">
<li class="const">Editing.MouseObject</li>
<li class="const">Editing.MouseRange</li>
<li class="const">Editing.MouseCut</li>
<li class="const">Editing.MouseTimeFX</li>
<li class="const">Editing.MouseAudition</li>
<li class="const">Editing.MouseDraw</li>
<li class="const">Editing.MouseContent</li>
</ul>
<h3 id="Editing.ZoomFocus" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.ZoomFocus</h3>
<ul class="enum">
<li class="const">Editing.ZoomFocusLeft</li>
<li class="const">Editing.ZoomFocusRight</li>
<li class="const">Editing.ZoomFocusCenter</li>
<li class="const">Editing.ZoomFocusPlayhead</li>
<li class="const">Editing.ZoomFocusMouse</li>
<li class="const">Editing.ZoomFocusEdit</li>
</ul>
<h3 id="Editing.DisplayControl" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.DisplayControl</h3>
<ul class="enum">
<li class="const">Editing.FollowPlayhead</li>
<li class="const">Editing.ShowMeasures</li>
<li class="const">Editing.ShowWaveforms</li>
<li class="const">Editing.ShowWaveformsRecording</li>
</ul>
<h3 id="Editing.ImportMode" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.ImportMode</h3>
<ul class="enum">
<li class="const">Editing.ImportAsRegion</li>
<li class="const">Editing.ImportToTrack</li>
<li class="const">Editing.ImportAsTrack</li>
<li class="const">Editing.ImportAsTapeTrack</li>
</ul>
<h3 id="Editing.ImportPosition" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.ImportPosition</h3>
<ul class="enum">
<li class="const">Editing.ImportAtTimestamp</li>
<li class="const">Editing.ImportAtEditPoint</li>
<li class="const">Editing.ImportAtPlayhead</li>
<li class="const">Editing.ImportAtStart</li>
</ul>
<h3 id="Editing.ImportDisposition" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;Editing.ImportDisposition</h3>
<ul class="enum">
<li class="const">Editing.ImportDistinctFiles</li>
<li class="const">Editing.ImportMergeFiles</li>
<li class="const">Editing.ImportSerializeFiles</li>
<li class="const">Editing.ImportDistinctChannels</li>
</ul>
<h3 id="ARDOUR.DSP.BiQuad.Type" class="cls enum"><abbr title="Enum">&isin;</abbr>&nbsp;ARDOUR.DSP.BiQuad.Type</h3>
<ul class="enum">
<li class="const">ARDOUR.DSP.BiQuadType.LowPass</li>
<li class="const">ARDOUR.DSP.BiQuadType.HighPass</li>
<li class="const">ARDOUR.DSP.BiQuadType.BandPassSkirt</li>
<li class="const">ARDOUR.DSP.BiQuadType.BandPass0dB</li>
<li class="const">ARDOUR.DSP.BiQuadType.Notch</li>
<li class="const">ARDOUR.DSP.BiQuadType.AllPass</li>
<li class="const">ARDOUR.DSP.BiQuadType.Peaking</li>
<li class="const">ARDOUR.DSP.BiQuadType.LowShelf</li>
<li class="const">ARDOUR.DSP.BiQuadType.HighShelf</li>
</ul>
<h2 id="h_index" >Class Index</h2>
<ul class="classindex">
<li><a class="" href="#ARDOUR:AudioBackend">ARDOUR:AudioBackend</a></li>
<li><a class="" href="#ARDOUR:AudioBackendInfo">ARDOUR:AudioBackendInfo</a></li>
<li><a class="" href="#ARDOUR:AudioBuffer">ARDOUR:AudioBuffer</a></li>
<li><a class="" href="#ARDOUR:AudioEngine">ARDOUR:AudioEngine</a></li>
<li><a class="" href="#ARDOUR:AudioSource">ARDOUR:AudioSource</a></li>
<li><a class="" href="#ARDOUR:AudioTrack">ARDOUR:AudioTrack</a></li>
<li><a class="" href="#ARDOUR:AudioTrackList">ARDOUR:AudioTrackList</a></li>
<li><a class="" href="#ARDOUR:Automatable">ARDOUR:Automatable</a></li>
<li><a class="" href="#ARDOUR:AutomationControl">ARDOUR:AutomationControl</a></li>
<li><a class="" href="#ARDOUR:BackendVector">ARDOUR:BackendVector</a></li>
<li><a class="" href="#ARDOUR:BufferSet">ARDOUR:BufferSet</a></li>
<li><a class="" href="#ARDOUR:ChanCount">ARDOUR:ChanCount</a></li>
<li><a class="" href="#ARDOUR:ChanMapping">ARDOUR:ChanMapping</a></li>
<li><a class="" href="#ARDOUR:DSP">ARDOUR.DSP</a></li>
<li><a class="" href="#ARDOUR:DSP:Biquad">ARDOUR:DSP:Biquad</a></li>
<li><a class="" href="#ARDOUR:DSP:DspShm">ARDOUR:DSP:DspShm</a></li>
<li><a class="" href="#ARDOUR:DSP:LowPass">ARDOUR:DSP:LowPass</a></li>
<li><a class="" href="#ARDOUR:DataType">ARDOUR:DataType</a></li>
<li><a class="" href="#ARDOUR:DeviceStatus">ARDOUR:DeviceStatus</a></li>
<li><a class="" href="#ARDOUR:DeviceStatusVector">ARDOUR:DeviceStatusVector</a></li>
<li><a class="" href="#ARDOUR:IO">ARDOUR:IO</a></li>
<li><a class="" href="#ARDOUR:IOProcessor">ARDOUR:IOProcessor</a></li>
<li><a class="" href="#ARDOUR:Location">ARDOUR:Location</a></li>
<li><a class="" href="#ARDOUR:LuaAPI">ARDOUR.LuaAPI</a></li>
<li><a class="" href="#ARDOUR:LuaOSC:Address">ARDOUR:LuaOSC:Address</a></li>
<li><a class="" href="#ARDOUR:Meter">ARDOUR:Meter</a></li>
<li><a class="" href="#ARDOUR:MidiBuffer">ARDOUR:MidiBuffer</a></li>
<li><a class="" href="#ARDOUR:MidiTrack">ARDOUR:MidiTrack</a></li>
<li><a class="" href="#ARDOUR:MidiTrackList">ARDOUR:MidiTrackList</a></li>
<li><a class="" href="#ARDOUR:OwnedPropertyList">ARDOUR:OwnedPropertyList</a></li>
<li><a class="" href="#ARDOUR:ParameterDescriptor">ARDOUR:ParameterDescriptor</a></li>
<li><a class="" href="#ARDOUR:Plugin">ARDOUR:Plugin</a></li>
<li><a class="" href="#ARDOUR:PluginControl">ARDOUR:PluginControl</a></li>
<li><a class="" href="#ARDOUR:PluginInfo">ARDOUR:PluginInfo</a></li>
<li><a class="" href="#ARDOUR:PluginInsert">ARDOUR:PluginInsert</a></li>
<li><a class="" href="#ARDOUR:PresetRecord">ARDOUR:PresetRecord</a></li>
<li><a class="" href="#ARDOUR:Processor">ARDOUR:Processor</a></li>
<li><a class="" href="#ARDOUR:Properties:BoolProperty">ARDOUR:Properties:BoolProperty</a></li>
<li><a class="" href="#ARDOUR:Properties:FloatProperty">ARDOUR:Properties:FloatProperty</a></li>
<li><a class="" href="#ARDOUR:Properties:FrameposProperty">ARDOUR:Properties:FrameposProperty</a></li>
<li><a class="" href="#ARDOUR:PropertyChange">ARDOUR:PropertyChange</a></li>
<li><a class="" href="#ARDOUR:PropertyList">ARDOUR:PropertyList</a></li>
<li><a class="" href="#ARDOUR:Region">ARDOUR:Region</a></li>
<li><a class="" href="#ARDOUR:RegionFactory">ARDOUR:RegionFactory</a></li>
<li><a class="" href="#ARDOUR:Route">ARDOUR:Route</a></li>
<li><a class="" href="#ARDOUR:Route:ProcessorStreams">ARDOUR:Route:ProcessorStreams</a></li>
<li><a class="" href="#ARDOUR:RouteList">ARDOUR:RouteList</a></li>
<li><a class="" href="#ARDOUR:RouteListPtr">ARDOUR:RouteListPtr</a></li>
<li><a class="" href="#ARDOUR:Session">ARDOUR:Session</a></li>
<li><a class="" href="#ARDOUR:SessionObject">ARDOUR:SessionObject</a></li>
<li><a class="" href="#ARDOUR:SideChain">ARDOUR:SideChain</a></li>
<li><a class="" href="#ARDOUR:Source">ARDOUR:Source</a></li>
<li><a class="" href="#ARDOUR:Tempo">ARDOUR:Tempo</a></li>
<li><a class="" href="#ARDOUR:TempoMap">ARDOUR:TempoMap</a></li>
<li><a class="" href="#ARDOUR:Track">ARDOUR:Track</a></li>
<li><a class="" href="#ARDOUR:WeakAudioSourceList">ARDOUR:WeakAudioSourceList</a></li>
<li><a class="" href="#ARDOUR:WeakPortSet">ARDOUR:WeakPortSet</a></li>
<li><a class="" href="#ARDOUR:WeakRouteList">ARDOUR:WeakRouteList</a></li>
<li><a class="" href="#ARDOUR:WeakSourceList">ARDOUR:WeakSourceList</a></li>
<li><a class="" href="#ArdourUI:ArdourMarker">ArdourUI:ArdourMarker</a></li>
<li><a class="" href="#ArdourUI:Editor">ArdourUI:Editor</a></li>
<li><a class="" href="#ArdourUI:RegionSelection">ArdourUI:RegionSelection</a></li>
<li><a class="" href="#C:DoubleVector">C:DoubleVector</a></li>
<li><a class="" href="#C:FloatArray">C:FloatArray</a></li>
<li><a class="" href="#C:IntArray">C:IntArray</a></li>
<li><a class="" href="#C:StringList">C:StringList</a></li>
<li><a class="" href="#C:StringVector">C:StringVector</a></li>
<li><a class="" href="#Cairo:Context">Cairo:Context</a></li>
<li><a class="" href="#Evoral:Beats">Evoral:Beats</a></li>
<li><a class="" href="#Evoral:Control">Evoral:Control</a></li>
<li><a class="" href="#Evoral:ControlList">Evoral:ControlList</a></li>
<li><a class="" href="#Evoral:ControlSet">Evoral:ControlSet</a></li>
<li><a class="" href="#Evoral:Event">Evoral:Event</a></li>
<li><a class="" href="#Evoral:MidiEvent">Evoral:MidiEvent</a></li>
<li><a class="" href="#Evoral:Parameter">Evoral:Parameter</a></li>
<li><a class="" href="#Evoral:ParameterDescriptor">Evoral:ParameterDescriptor</a></li>
<li><a class="" href="#LuaSignal:Set">LuaSignal:Set</a></li>
<li><a class="" href="#PBD:Controllable">PBD:Controllable</a></li>
<li><a class="" href="#PBD:ID">PBD:ID</a></li>
<li><a class="" href="#PBD:Stateful">PBD:Stateful</a></li>
<li><a class="" href="#PBD:StatefulDestructible">PBD:StatefulDestructible</a></li>
<li><a class="" href="#PBD:StatefulDestructiblePtr">PBD:StatefulDestructiblePtr</a></li>
<li><a class="" href="#PBD:StatefulPtr">PBD:StatefulPtr</a></li>
<li><a class="" href="#Timecode:BBT_TIME">Timecode:BBT_TIME</a></li>
</ul>
</div>
<div class="luafooter">Ardour 4.7-626-g5e2c9f8 &nbsp;-&nbsp; Wed, 06 Apr 2016 18:47:33 +0200</div>
